
@incollection{StadlerMarkus2001PVSS,
	address = {Berlin, Heidelberg},
	series = {Lecture notes in computer science},
	title = {Publicly verifiable secret sharing},
	isbn = {3-540-61186-X},
	abstract = {A secret sharing scheme allows to share a secret among several participants such that only certain groups of them can recover it. Verifiable secret sharing has been proposed to achieve security against cheating participants. Its first realization had the special property that everybody, not only the participants, can verify that the shares are cor- rectly distributed. We will call such schemes publicly verifiable secret sharing schemes, we discuss new applications to escrow cryptosystems and to payment systems with revocable anonymity, and we present two new realizations based on ElGamal’s cryptosystem.},
	language = {english},
	booktitle = {Advances in cryptology — {EUROCRYPT} ’96},
	publisher = {Springer Berlin Heidelberg},
	author = {Stadler, Markus},
	year = {2001},
	note = {ISSN: 0302-9743
tex.copyright: Springer-Verlag Berlin Heidelberg 1996},
	keywords = {Access Structure, Discrete Logarithm, Secret Sharing, Secret Sharing Scheme, Signature Scheme},
	pages = {190--199},
}

@misc{Nakamoto_bitcoin,
	title = {Bitcoin: {A} peer-to-peer electronic cash system},
	url = {http://bitcoin.org/bitcoin.pdf},
	author = {Nakamoto, Satoshi},
}

@inproceedings{schindler_hydrand_2020,
	title = {{HydRand}: {Efficient} {Continuous} {Distributed} {Randomness}},
	shorttitle = {{HydRand}},
	doi = {10.1109/SP40000.2020.00003},
	abstract = {A reliable source of randomness is not only an essential building block in various cryptographic, security, and distributed systems protocols, but also plays an integral part in the design of many new blockchain proposals. Consequently, the topic of publicly-verifiable, bias-resistant and unpredictable randomness has recently enjoyed increased attention. In particular random beacon protocols, aimed at continuous operation, can be a vital component for current Proof-of-Stake based distributed ledger proposals. We improve upon previous random beacon approaches with HydRand, a novel distributed protocol based on publicly-verifiable secret sharing (PVSS) to ensure unpredictability, bias-resistance, and public-verifiability of a continuous sequence of random beacon values. Furthermore, HydRand provides guaranteed output delivery of randomness at regular and predictable intervals in the presence of adversarial behavior and does not rely on a trusted dealer for the initial setup. Compared to existing PVSS based approaches that strive to achieve similar properties, our solution improves scalability by lowering the communication complexity from \${\textbackslash}mathcalO{\textbackslash}left( n{\textasciicircum}3 {\textbackslash}right)\$ to \${\textbackslash}mathcalO{\textbackslash}left( n{\textasciicircum}2 {\textbackslash}right)\$ . Furthermore, we are the first to present a detailed comparison of recently described schemes and protocols that can be used for implementing random beacons.},
	booktitle = {2020 {IEEE} {Symposium} on {Security} and {Privacy} ({SP})},
	author = {Schindler, Philipp and Judmayer, Aljosha and Stifter, Nicholas and Weippl, Edgar},
	month = may,
	year = {2020},
	note = {ISSN: 2375-1207},
	keywords = {Proposals, Protocols, Public key},
	pages = {73--89},
}

@misc{cryptoeprint:2011:565,
	title = {Cryptographic hash functions: {Recent} design trends and security notions},
	author = {Al-Kuwari, Saif and Davenport, James H. and Bradford, Russell J.},
	year = {2011},
	note = {Cryptology ePrint Archive, Report 2011/565},
}

@inproceedings{nguyen-van_scalable_2019,
	title = {Scalable {Distributed} {Random} {Number} {Generation} {Based} on {Homomorphic} {Encryption}},
	doi = {10.1109/Blockchain.2019.00083},
	abstract = {Generating a secure source of publicly-verifiable randomness could be the single most fundamental technical challenge on a distributed network, especially in the blockchain context. Many current proposals face serious problems of scalability and security issues. We present a protocol which can be implemented on a blockchain that ensures unpredictable, tamper-resistant, scalable and publicly-verifiable outcomes. The main building blocks of our protocol are homomorphic encryption (HE) and verifiable random functions (VRF). The use of homomorphic encryption enables mathematical operations to be performed on encrypted data, to ensure no one knows the outcome prior to being generated. The protocol requires O(n) elliptic curve multiplications and additions as well as O(n) signature signing and verification operations, which permits great scalability. We present a comparison between recent approaches to the generation of random beacons.},
	booktitle = {2019 {IEEE} {International} {Conference} on {Blockchain} ({Blockchain})},
	author = {Nguyen-Van, Thanh and Nguyen-Anh, Tuan and Le, Tien-Dat and Nguyen-Ho, Minh-Phuoc and Nguyen-Van, Tuong and Le, Nhat-Quang and Nguyen-An, Khuong},
	month = jul,
	year = {2019},
	keywords = {Blockchain, Complexity theory, Elliptic curves, Encryption, Protocols, random beacons, homomorphic encryption, elliptic curve cryptography, verifiable random function, distributed ledgers, decentralized schemes, blockchain based applications},
	pages = {572--579},
}

@inproceedings{MerlinChains,
	title = {Cryptocurrency smart contracts for distributed consensus of public randomness},
	doi = {https://doi.org/10.1007/978-3-319-69084-1_31},
	language = {english},
	publisher = {Proceedings of the 19th International Symposium on Stabilization, Safety, and Security of Distributed Systems, Boston, MA},
	author = {Mell, Peter and Kelsey, John and Shook, James},
	year = {2017},
	note = {Number: 10616},
}

@misc{rescorla_transport_2018,
	title = {The transport layer security ({TLS}) protocol version 1.3},
	url = {https://www.rfc-editor.org/info/rfc8446},
	abstract = {This document specifies version 1.3 of the Transport Layer Security (TLS) protocol. TLS allows client/server applications to communicate over the Internet in a way that is designed to prevent eavesdropping, tampering, and message forgery. This document updates RFCs 5705 and 6066, and obsoletes RFCs 5077, 5246, and 6961. This document also specifies new requirements for TLS 1.2 implementations.},
	publisher = {RFC Editor},
	author = {Rescorla, Eric},
	month = aug,
	year = {2018},
}

@incollection{alma9928100443506253,
	address = {Cham},
	series = {{SpringerBriefs} in computer science},
	title = {Homomorphic encryption and applications},
	isbn = {3-319-12229-0},
	abstract = {This book introduces the fundamental concepts of homomorphic encryption. From these foundations, applications are developed in the fields of private information retrieval, private searching on streaming data, privacy-preserving data mining, electronic voting and cloud computing. The content is presented in an instructional and practical style, with concrete examples to enhance the reader's understanding. This volume achieves a balance between the theoretical and the practical components of modern information security. Readers will learn key principles of homomorphic encryption as well as their application in solving real world problems.},
	language = {english},
	booktitle = {Homomorphic encryption and applications},
	publisher = {Springer},
	author = {Yi, Xun},
	year = {2014},
	keywords = {Data encryption (Computer science)},
}

@misc{noauthor_solidity_nodate,
	title = {Solidity documentation},
	url = {https://docs.soliditylang.org},
	urldate = {2022-03-26},
}

@misc{noauthor_algorand_nodate,
	title = {Algorand ({ALGO}) {Blockchain} {Explorer}},
	url = {https://algoexplorer.io/},
	abstract = {AlgoExplorer allows you to explore and search the Algorand blockchain for transactions, 
						addresses, stake rewards, stats, tokens, price and other activities taking place on the Algorand network.},
	urldate = {2022-03-26},
}

@article{pierrot_malleability_2018,
	title = {Malleability of the blockchain’s entropy},
	volume = {10},
	issn = {1936-2455},
	url = {https://doi.org/10.1007/s12095-017-0264-3},
	doi = {10.1007/s12095-017-0264-3},
	abstract = {Trustworthy generation of public random numbers is necessary for the security of a number of cryptographic applications. It was suggested to use the inherent unpredictability of blockchains as a source of public randomness. Entropy from the Bitcoin blockchain in particular has been used in lotteries and has been suggested for a number of other applications ranging from smart contracts to election auditing. In this Arcticle, we analyse this idea and show how an adversary could manipulate these random numbers, even with limited computational power and financial budget.},
	language = {en},
	number = {1},
	urldate = {2022-03-24},
	journal = {Cryptography and Communications},
	author = {Pierrot, Cécile and Wesolowski, Benjamin},
	month = jan,
	year = {2018},
	pages = {211--233},
}

@misc{etherscanio_ethereum_nodate,
	title = {Ethereum {Gas} {Tracker} {\textbar} {Etherscan}},
	url = {http://etherscan.io/gastracker},
	abstract = {Gas Snapshot Price at 3/22/2022 1:08:37 PM UTC - Low: 23 gwei {\textbar} Avg: 23 gwei {\textbar} High: 24 gwei},
	language = {en},
	urldate = {2022-03-22},
	journal = {Ethereum (ETH) Blockchain Explorer},
	author = {{etherscan.io}},
}

@misc{buterin_ethereum_2014,
	title = {Ethereum: {A} {Next}-{Generation} {Smart} {Contract} and {Decentralized} {Application} {Platform}.},
	url = {https://ethereum.org/en/whitepaper/},
	urldate = {2022-03-26},
	collaborator = {Buterin, Vitalik},
	year = {2014},
}

@inproceedings{10.1109/SFCS.1983.48,
	address = {USA},
	series = {{SFCS} '83},
	title = {Randomized byzantine generals},
	isbn = {0-8186-0508-1},
	url = {https://doi.org/10.1109/SFCS.1983.48},
	doi = {10.1109/SFCS.1983.48},
	abstract = {We present a randomized solution for the Byzantine Generals Problems. The solution works in the synchronous as well as the asynchronous case and produces Byzantine Agreement within a fixed small expected number of computational rounds, independent of the number n of processes and the bound t on the number of faulty processes. The solution uses A. Shamir's method for sharing secrets. It specializes to produce a simple solution for the Distributed Commit problem.},
	booktitle = {Proceedings of the 24th annual symposium on foundations of computer science},
	publisher = {IEEE Computer Society},
	author = {Rabin, Michael O.},
	year = {1983},
	note = {Number of pages: 7},
	pages = {403--409},
}

@article{10.1145/322186.322188,
	title = {Reaching agreement in the presence of faults},
	volume = {27},
	issn = {0004-5411},
	url = {https://doi.org/10.1145/322186.322188},
	doi = {10.1145/322186.322188},
	abstract = {The problem addressed here concerns a set of isolated processors, some unknown subset of which may be faulty, that communicate only by means of two-party messages. Each nonfaulty processor has a private value of information that must be communicated to each other nonfaulty processor. Nonfaulty processors always communicate honestly, whereas faulty processors may lie. The problem is to devise an algorithm in which processors communicate their own values and relay values received from others that allows each nonfaulty processor to infer a value for each other processor. The value inferred for a nonfaulty processor must be that processor's private value, and the value inferred for a faulty one must be consistent with the corresponding value inferred by each other nonfaulty processor.It is shown that the problem is solvable for, and only for, n ≥ 3m + 1, where m is the number of faulty processors and n is the total number. It is also shown that if faulty processors can refuse to pass on information but cannot falsely relay information, the problem is solvable for arbitrary n ≥ m ≥ 0. This weaker assumption can be approximated in practice using cryptographic methods.},
	number = {2},
	journal = {Journal of The Acm},
	author = {Pease, M. and Shostak, R. and Lamport, L.},
	month = apr,
	year = {1980},
	note = {Number of pages: 7
Place: New York, NY, USA
Publisher: Association for Computing Machinery
tex.issue\_date: April 1980},
	pages = {228--234},
}

@misc{noauthor_bitcoin_nodate,
	title = {Bitcoin - {Open} source {P2P} money},
	url = {https://bitcoin.org/en/},
	abstract = {Bitcoin is an innovative payment network and a new kind of money. Find all you need to know and get started with Bitcoin on bitcoin.org.},
	language = {en},
	urldate = {2022-03-21},
}

@misc{noauthor_ethereum_nodate,
	title = {Ethereum},
	url = {https://ethereum.org},
	abstract = {Ethereum is a global, decentralized platform for money and new kinds of applications. On Ethereum, you can write code that controls money, and build applications accessible anywhere in the world.},
	language = {en},
	urldate = {2022-03-21},
	journal = {ethereum.org},
}

@incollection{RogawayPhillip2004CHBD,
	address = {Berlin, Heidelberg},
	series = {Lecture notes in computer science},
	title = {Cryptographic hash-function basics: {Definitions}, implications, and separations for preimage resistance, second-preimage resistance, and collision resistance},
	isbn = {3-540-22171-9},
	abstract = {We consider basic notions of security for cryptographic hash functions: collision resistance, preimage resistance, and second-preimage resistance. We give seven different definitions that correspond to these three underlying ideas, and then we work out all of the implications and separations among these seven definitions within the concrete-security, provable-security framework. Because our results are concrete, we can show two types of implications, conventional and provisional, where the strength of the latter depends on the amount of compression achieved by the hash function. We also distinguish two types of separations, conditional and unconditional. When constructing counterexamples for our separations, we are careful to preserve specified hash-function domains and ranges; this rules out some pathological counterexamples and makes the separations more meaningful in practice. Four of our definitions are standard while three appear to be new; some of our relations and separations have appeared, others have not. Here we give a modern treatment that acts to catalog, in one place and with carefully-considered nomenclature, the most basic security notions for cryptographic hash functions.},
	language = {english},
	booktitle = {Fast software encryption},
	publisher = {Springer Berlin Heidelberg},
	author = {Rogaway, Phillip and Shrimpton, Thomas},
	year = {2004},
	note = {ISSN: 0302-9743
tex.copyright: Springer-Verlag Berlin Heidelberg 2004},
	keywords = {Applied sciences, Cryptography, Exact sciences and technology, Information, Signal and communications theory, Telecommunications and information theory, collision resistance, cryptographic hash functions, preimage resistance, provable security, second-preimage resistance, signal and communications theory},
	pages = {371--388},
}

@misc{noauthor_sustainable_nodate,
	title = {Sustainable {Blockchain}: {Estimating} the {Carbon} {Footprint} of {Algorand}’s {Pure} {Proof}-of-{Stake}},
	shorttitle = {Sustainable {Blockchain}},
	url = {https://www.algorand.com/resources/blog/sustainable-blockchain-calculating-the-carbon-footprint/},
	abstract = {Pure Proof of Stake offers security, scalability, decentralization and… sustainability!},
	language = {en},
	urldate = {2022-03-18},
}

@misc{noauthor_cambridge_nodate,
	title = {Cambridge {Bitcoin} {Electricity} {Consumption} {Index} ({CBECI})},
	url = {https://ccaf.io/cbeci/index},
	abstract = {The Cambridge Bitcoin Electricity Consumption Index (CBECI) provides a real-time estimate of the total electricity consumption of the Bitcoin network. The CBECI is maintained by the Cambridge Centre for Alternative Finance (CCAF) at Judge Business School, University of Cambridge.},
	language = {en},
	urldate = {2022-03-18},
}

@article{hanke_dfinity_2018,
	title = {{DFINITY} {Technology} {Overview} {Series}, {Consensus} {System}},
	url = {http://arxiv.org/abs/1805.04548},
	abstract = {The DFINITY blockchain computer provides a secure, performant and flexible consensus mechanism. At its core, DFINITY contains a decentralized randomness beacon which acts as a verifiable random function (VRF) that produces a stream of outputs over time. The novel technique behind the beacon relies on the existence of a unique-deterministic, non-interactive, DKG-friendly threshold signatures scheme. The only known examples of such a scheme are pairing-based and derived from BLS. The DFINITY blockchain is layered on top of the DFINITY beacon and uses the beacon as its source of randomness for leader selection and leader ranking. A "weight" is attributed to a chain based on the ranks of the leaders who propose the blocks in the chain, and that weight is used to select between competing chains. The DFINITY blockchain is layered on top of the DFINITY beacon and uses the beacon as its source of randomness for leader selection and leader ranking blockchain is further hardened by a notarization process which dramatically improves the time to finality and eliminates the nothing-at-stake and selfish mining attacks. DFINITY consensus algorithm is made to scale through continuous quorum selections driven by the random beacon. In practice, DFINITY achieves block times of a few seconds and transaction finality after only two confirmations. The system gracefully handles temporary losses of network synchrony including network splits, while it is provably secure under synchrony.},
	urldate = {2022-03-18},
	journal = {arXiv:1805.04548 [cs]},
	author = {Hanke, Timo and Movahedi, Mahnush and Williams, Dominic},
	month = may,
	year = {2018},
	note = {arXiv: 1805.04548},
	keywords = {Computer Science - Distributed, Parallel, and Cluster Computing},
}

@article{fischer_impossibility_1985,
	title = {Impossibility of distributed consensus with one faulty process},
	volume = {32},
	issn = {0004-5411, 1557-735X},
	url = {https://dl.acm.org/doi/10.1145/3149.214121},
	doi = {10.1145/3149.214121},
	abstract = {The consensus problem involves an asynchronous system of processes, some of which may be unreliable. The problem is for the reliable processes to agree on a binary value. In this paper, it is shown that every protocol for this problem has the possibility of nontermination, even with only one faulty process. By way of contrast, solutions are known for the synchronous case, the “Byzantine Generals” problem.},
	language = {en},
	number = {2},
	urldate = {2022-03-17},
	journal = {Journal of the ACM},
	author = {Fischer, Michael J. and Lynch, Nancy A. and Paterson, Michael S.},
	month = apr,
	year = {1985},
	pages = {374--382},
}

@misc{computer_security_division_interoperable_2019,
	title = {Interoperable {Randomness} {Beacons} {\textbar} {CSRC} {\textbar} {CSRC}},
	url = {https://csrc.nist.gov/projects/interoperable-randomness-beacons},
	abstract = {The Interoperable Randomness Beacons project at NIST intends to promote the availability of trusted public randomness as a public utility. This can be used for example for auditability and transparency of services that depend on randomized processes.  The project is spearheaded by the Cryptographic Technology Group in the Computer Security Division of the Information Technology Laboratory (ITL), and has counted with the participation of many collaborators over the years.  WARNING: Do NOT use Beacon generated values as cryptographic secret keys!  The webpage of the NIST Randomness Beacon (with actual random values) is located at: https://beacon.nist.gov/home      Historical notes      Collaborators: Ron Rivest played an important early role in motivating the creation of the project, by pointing out to NIST that a public source of randomness could be valuable for auditing voting machines. Michael Fischer was a valuable early collaborator in thinking about a theoretical framework for public randomness. Andrew...},
	language = {EN-US},
	urldate = {2022-03-17},
	journal = {CSRC {\textbar} NIST},
	author = {Computer Security Division, Information Technology Laboratory},
	month = jun,
	year = {2019},
}

@article{wesolowski_efficient_2020,
	title = {Efficient {Verifiable} {Delay} {Functions}},
	volume = {33},
	issn = {1432-1378},
	url = {https://doi.org/10.1007/s00145-020-09364-x},
	doi = {10.1007/s00145-020-09364-x},
	abstract = {We construct a verifiable delay function (VDF). A VDF is a function whose evaluation requires running a given number of sequential steps, yet the result can be efficiently verified. They have applications in decentralised systems, such as the generation of trustworthy public randomness in a trustless environment, or resource-efficient blockchains. To construct our VDF, we actually build a trapdoor VDF. A trapdoor VDF is essentially a VDF which can be evaluated efficiently by parties who know a secret (the trapdoor). By setting up this scheme in a way that the trapdoor is unknown (not even by the party running the setup, so that there is no need for a trusted setup environment), we obtain a simple VDF. Our construction is based on groups of unknown order such as an RSA group or the class group of an imaginary quadratic field. The output of our construction is very short (the result and the proof of correctness are each a single element of the group), and the verification of correctness is very efficient.},
	language = {en},
	number = {4},
	urldate = {2022-03-15},
	journal = {Journal of Cryptology},
	author = {Wesolowski, Benjamin},
	month = oct,
	year = {2020},
	pages = {2113--2147},
}

@techreport{10.5555/888615,
	address = {USA},
	title = {Time-lock puzzles and timed-release crypto},
	abstract = {Our motivation is the notion of “timed-release crypto,”” where the goal is to encrypt a message so that it can not be decrypted by anyone, not even the sender, until a pre-determined amount of time has passed. The goal is to “send information into the future.”” This problem was first discussed by Timothy May citeMay93. What are the applications of “timed-release crypto””? Here are a few possibilities (some due to May): A bidder in an auction wants to seal his bid so that it can only be opened after the bidding period is closed. A homeowner wants to give his mortgage holder a series of encrypted mortgage payments. These might be encrypted digital cash with different decryption dates, so that one payment becomes decryptable (and thus usable by the bank) at the beginning of each successive month. An individual wants to encrypt his diaries so that they are only decryptable after fifty years. A key-escrow scheme can be based on timed-release crypto, so that the government can get the message keys, but only after a fixed period (say one year). There are presumably many other applications. There are two natural approaches to implementing timed-release crypto: Use “time-lock puzzles””–computational problems that can not be solved without running a computer continuously for at least a certain amount of time. Use trusted agents who promise not to reveal certain information until a specified date. Using trusted agents has the obvious problem of ensuring that the agents are trustworthy; secret-sharing approaches can be used to alleviate this concern. Using time-lock puzzles has the problem that the CPU time required to solve a problem can depend on the amount and nature of the hardware used to solve the problem, as well as the parallelizability of the computational problem being solved. In this note we explore both approaches. (We note that Tim May has suggested an approach based on the use of trusted agents.)},
	institution = {Massachusetts Institute of Technology},
	author = {Rivest, R. L. and Shamir, A. and Wagner, D. A.},
	year = {1996},
}

@techreport{rivest_time-lock_1996,
	address = {USA},
	type = {Technical {Report}},
	title = {Time-lock {Puzzles} and {Timed}-release {Crypto}},
	abstract = {Our motivation is the notion of ``timed-release crypto,'''' where the goal is to encrypt a message so that it can not be decrypted by anyone, not even the sender, until a pre-determined amount of time has passed. The goal is to ``send information into the future.'''' This problem was first discussed by Timothy May {\textbackslash}cite\{May93\}. What are the applications of ``timed-release crypto''''? Here are a few possibilities (some due to May): A bidder in an auction wants to seal his bid so that it can only be opened after the bidding period is closed. A homeowner wants to give his mortgage holder a series of encrypted mortgage payments. These might be encrypted digital cash with different decryption dates, so that one payment becomes decryptable (and thus usable by the bank) at the beginning of each successive month. An individual wants to encrypt his diaries so that they are only decryptable after fifty years. A key-escrow scheme can be based on timed-release crypto, so that the government can get the message keys, but only after a fixed period (say one year). {\textbackslash} There are presumably many other applications. There are two natural approaches to implementing timed-release crypto: Use ``time-lock puzzles''''--computational problems that can not be solved without running a computer continuously for at least a certain amount of time. Use trusted agents who promise not to reveal certain information until a specified date. Using trusted agents has the obvious problem of ensuring that the agents are trustworthy; secret-sharing approaches can be used to alleviate this concern. Using time-lock puzzles has the problem that the CPU time required to solve a problem can depend on the amount and nature of the hardware used to solve the problem, as well as the parallelizability of the computational problem being solved. In this note we explore both approaches. (We note that Tim May has suggested an approach based on the use of trusted agents.)},
	institution = {Massachusetts Institute of Technology},
	author = {Rivest, R. L. and Shamir, A. and Wagner, D. A.},
	year = {1996},
}

@book{bertino_computer_2021,
	address = {Cham, Switzerland},
	series = {Lecture notes in computer science},
	title = {Computer security – {ESORICS} 2021: 26th {European} {Symposium} on {Research} in {Computer} {Security}, {Darmstadt}, {Germany}, {October} 4–8, 2021: proceedings. {Part} 2},
	isbn = {9783030884277},
	shorttitle = {Computer security – {ESORICS} 2021},
	language = {eng},
	number = {12973},
	publisher = {Springer},
	editor = {Bertino, Elisa and Shulman, Haya and Waidner, Michael},
	year = {2021},
}

@inproceedings{10.1145/12130.12168,
	address = {New York, NY, USA},
	series = {{STOC} '86},
	title = {Limits on the security of coin flips when half the processors are faulty},
	isbn = {0-89791-193-8},
	url = {https://doi-org.libproxy.helsinki.fi/10.1145/12130.12168},
	doi = {10.1145/12130.12168},
	booktitle = {Proceedings of the eighteenth annual {ACM} symposium on theory of computing},
	publisher = {Association for Computing Machinery},
	author = {Cleve, R},
	year = {1986},
	note = {Number of pages: 6
Place: Berkeley, California, USA},
	pages = {364--369},
}

@inproceedings{micali_verifiable_1999,
	title = {Verifiable random functions},
	doi = {10.1109/SFFCS.1999.814584},
	booktitle = {40th {Annual} {Symposium} on {Foundations} of {Computer} {Science} ({Cat}. {No}.{99CB37039})},
	author = {Micali, S. and Rabin, M. and Vadhan, S.},
	year = {1999},
	pages = {120--130},
}

@article{goldreich_how_1986,
	title = {How to {Construct} {Random} {Functions}},
	volume = {33},
	issn = {0004-5411},
	url = {https://doi.org/10.1145/6490.6503},
	doi = {10.1145/6490.6503},
	abstract = {A constructive theory of randomness for functions, based on computational complexity, is developed, and a pseudorandom function generator is presented. This generator is a deterministic polynomial-time algorithm that transforms pairs (g, r), where g is any one-way function and r is a random k-bit string, to polynomial-time computable functions undefinedr: 1, … , 2k → 1, … , 2k. These undefinedr's cannot be distinguished from random functions by any probabilistic polynomial-time algorithm that asks and receives the value of a function at arguments of its choice. The result has applications in cryptography, random constructions, and complexity theory.},
	number = {4},
	journal = {J. ACM},
	author = {Goldreich, Oded and Goldwasser, Shafi and Micali, Silvio},
	month = aug,
	year = {1986},
	note = {Place: New York, NY, USA
Publisher: Association for Computing Machinery},
	pages = {792--807},
}

@inproceedings{gilad_algorand_2017,
	address = {New York, NY, USA},
	series = {{SOSP} '17},
	title = {Algorand: {Scaling} {Byzantine} {Agreements} for {Cryptocurrencies}},
	isbn = {978-1-4503-5085-3},
	url = {https://doi.org/10.1145/3132747.3132757},
	doi = {10.1145/3132747.3132757},
	abstract = {Algorand is a new cryptocurrency that confirms transactions with latency on the order of a minute while scaling to many users. Algorand ensures that users never have divergent views of confirmed transactions, even if some of the users are malicious and the network is temporarily partitioned. In contrast, existing cryptocurrencies allow for temporary forks and therefore require a long time, on the order of an hour, to confirm transactions with high confidence.Algorand uses a new Byzantine Agreement (BA) protocol to reach consensus among users on the next set of transactions. To scale the consensus to many users, Algorand uses a novel mechanism based on Verifiable Random Functions that allows users to privately check whether they are selected to participate in the BA to agree on the next set of transactions, and to include a proof of their selection in their network messages. In Algorand's BA protocol, users do not keep any private state except for their private keys, which allows Algorand to replace participants immediately after they send a message. This mitigates targeted attacks on chosen participants after their identity is revealed.We implement Algorand and evaluate its performance on 1,000 EC2 virtual machines, simulating up to 500,000 users. Experimental results show that Algorand confirms transactions in under a minute, achieves 125x Bitcoin's throughput, and incurs almost no penalty for scaling to more users.},
	booktitle = {Proceedings of the 26th {Symposium} on {Operating} {Systems} {Principles}},
	publisher = {Association for Computing Machinery},
	author = {Gilad, Yossi and Hemo, Rotem and Micali, Silvio and Vlachos, Georgios and Zeldovich, Nickolai},
	year = {2017},
	note = {event-place: Shanghai, China},
	pages = {51--68},
}

@article{shamir_how_1979,
	title = {How to {Share} a {Secret}},
	volume = {22},
	issn = {0001-0782},
	url = {https://doi.org/10.1145/359168.359176},
	doi = {10.1145/359168.359176},
	abstract = {In this paper we show how to divide data D into n pieces in such a way that D is easily reconstructable from any k pieces, but even complete knowledge of k - 1 pieces reveals absolutely no information about D. This technique enables the construction of robust key management schemes for cryptographic systems that can function securely and reliably even when misfortunes destroy half the pieces and security breaches expose all but one of the remaining pieces.},
	number = {11},
	journal = {Commun. ACM},
	author = {Shamir, Adi},
	month = nov,
	year = {1979},
	note = {Place: New York, NY, USA
Publisher: Association for Computing Machinery},
	keywords = {cryptography, interpolation, key management},
	pages = {612--613},
}

@article{goldwasser_knowledge_1989,
	title = {The {Knowledge} {Complexity} of {Interactive} {Proof} {Systems}},
	volume = {18},
	url = {https://www.proquest.com/scholarly-journals/knowledge-complexity-interactive-proof-systems/docview/919784312/se-2},
	abstract = {Usually, a proof of a theorem contains more knowledge than the mere fact that the theorem is true. For instance, to prove that a graph is Hamiltonian it suffices to exhibit a Hamiltonian tour in it; however, this seems to contain more knowledge than the single bit Hamiltonian/non-Hamiltonian. In this paper a computational complexity theory of the "knowledge" contained in a proof is developed. Zero-knowledge proofs are defined as those proofs that convey no additional knowledge other than the correctness of the proposition in question. Examples of zero-knowledge proof systems are given for the languages of quadratic residuosity and 'quadratic nonresiduosity. These are the first examples of zero-knowledge proofs for languages not known to be efficiently recognizable.},
	language = {English},
	number = {1},
	journal = {SIAM Journal on Computing},
	author = {Goldwasser, Shafi and Micali, Silvio and Rackoff, Charles},
	month = feb,
	year = {1989},
	note = {ISBN: 00975397},
	keywords = {Algorithms, Coins, Computer science, Knowledge, Language, Mathematics, Probability distribution},
	pages = {186--23},
}

@article{dharanikota_breeding_2020,
	title = {Breeding unicorns: {Developing} trustworthy and scalable randomness beacons},
	volume = {15},
	issn = {1932-6203},
	shorttitle = {Breeding unicorns},
	url = {https://dx.plos.org/10.1371/journal.pone.0232261},
	doi = {10.1371/journal.pone.0232261},
	language = {en},
	number = {4},
	urldate = {2022-03-14},
	journal = {PLOS ONE},
	author = {Dharanikota, Samvid and Jensen, Michael Toft and Kristensen, Sebastian Rom and Michno, Mathias Sass and Pignolet, Yvonne-Anne and Rydhof Hansen, René and Schmid, Stefan},
	editor = {Debiao, He},
	month = apr,
	year = {2020},
	pages = {e0232261},
}

@article{cachin_random_2005,
	title = {Random {Oracles} in {Constantinople}: {Practical} {Asynchronous} {Byzantine} {Agreement} {Using} {Cryptography}},
	volume = {18},
	issn = {0933-2790, 1432-1378},
	shorttitle = {Random {Oracles} in {Constantinople}},
	url = {http://link.springer.com/10.1007/s00145-005-0318-0},
	doi = {10.1007/s00145-005-0318-0},
	language = {en},
	number = {3},
	urldate = {2022-03-14},
	journal = {Journal of Cryptology},
	author = {Cachin, Christian and Kursawe, Klaus and Shoup, Victor},
	month = jul,
	year = {2005},
	pages = {219--246},
}

@article{rabin_transaction_1983,
	title = {Transaction protection by beacons},
	volume = {27},
	issn = {0022-0000},
	url = {https://www.sciencedirect.com/science/article/pii/0022000083900429},
	doi = {10.1016/0022-0000(83)90042-9},
	abstract = {Protocols for implementing contract signing, confidential disclosures, and certified mail in an electronic mail system are proposed. These transactions are provably impossible without a trusted intermediary. However, they can be implemented with just a small probability of a participant cheating his partner, by use of a beacon emitting random integers. Applications include privacy protection of personal information in data banks, as well as the protection of business transactions.},
	language = {en},
	number = {2},
	urldate = {2022-03-14},
	journal = {Journal of Computer and System Sciences},
	author = {Rabin, Michael O.},
	month = oct,
	year = {1983},
	pages = {256--267},
}

@techreport{lenstra_random_2015,
	title = {A random zoo: sloth, unicorn, and trx},
	shorttitle = {A random zoo},
	url = {https://eprint.iacr.org/2015/366},
	abstract = {Many applications require trustworthy generation of public random numbers. It is shown how this can be achieved using a hash function that is timed to be as slow as desired (sloth), while the correctness of the resulting hash can be verified quickly. It is shown how sloth can be used for uncontestable random number generation (unicorn), and how unicorn can be used for a new trustworthy random elliptic curves service (trx) and random-sample voting.},
	number = {366},
	urldate = {2022-03-14},
	author = {Lenstra, Arjen K. and Wesolowski, Benjamin},
	year = {2015},
	keywords = {random-sample voting, slow-times hash, trustworthy random elliptic curves service, uncontestable random numbers},
}

@misc{corrigan-gibbs_ensuring_2014,
	title = {Ensuring {High}-{Quality} {Randomness} in {Cryptographic} {Key} {Generation}},
	author = {Corrigan-Gibbs, Henry and Mu, Wendy and Boneh, Dan and Ford, Bryan},
	year = {2014},
	note = {\_eprint: 1309.7366},
}

@misc{noauthor_hard_nodate,
	title = {Hard {Problems} of {Cryptocurrency} 2015},
	url = {https://eth.wiki/en/ideas/hpoc_2015},
	language = {en},
	urldate = {2022-02-08},
	journal = {Ethereum Wiki},
}

@inproceedings{boneh_verifiable_2018,
	series = {Lecture {Notes} in {Computer} {Science} (including subseries {Lecture} {Notes} in {Artificial} {Intelligence} and {Lecture} {Notes} in {Bioinformatics})},
	title = {Verifiable delay functions},
	isbn = {978-3-319-96883-4},
	doi = {10.1007/978-3-319-96884-1_25},
	abstract = {We study the problem of building a verifiable delay function (VDF). A VDF requires a specified number of sequential steps to evaluate, yet produces a unique output that can be efficiently and publicly verified. VDF s have many applications in decentralized systems, including public randomness beacons, leader election in consensus protocols, and proofs of replication. We formalize the requirements for VDF s and present new candidate constructions that are the first to achieve an exponential gap between evaluation and verification time.},
	language = {English (US)},
	booktitle = {Advances in {Cryptology} – {CRYPTO} 2018 - 38th {Annual} {International} {Cryptology} {Conference}, 2018, {Proceedings}},
	publisher = {Springer Verlag},
	author = {Boneh, Dan and Bonneau, Joseph and Bünz, Benedikt and Fisch, Ben},
	editor = {Boldyreva, Alexandra and Shacham, Hovav},
	year = {2018},
	pages = {757--788},
}

@inproceedings{syta_scalable_2017,
	title = {Scalable {Bias}-{Resistant} {Distributed} {Randomness}},
	doi = {10.1109/SP.2017.45},
	booktitle = {2017 {IEEE} {Symposium} on {Security} and {Privacy} ({SP})},
	author = {Syta, Ewa and Jovanovic, Philipp and Kogias, Eleftherios Kokoris and Gailly, Nicolas and Gasser, Linus and Khoffi, Ismail and Fischer, Michael J. and Ford, Bryan},
	year = {2017},
	pages = {444--460},
}

@misc{noauthor_verifiable_2020,
	title = {Verifiable {Randomness} for {Blockchain} {Smart} {Contracts}},
	url = {https://blog.chain.link/chainlink-vrf-on-chain-verifiable-randomness/},
	abstract = {Chainlink VRF (Verifiable Randomness Function) allows blockchain developers to easily add verifiable randomness to their smart contracts.},
	language = {en-US},
	urldate = {2022-02-09},
	journal = {Chainlink Blog},
	month = may,
	year = {2020},
}

@inproceedings{simic_review_2020,
	title = {A {Review} on {Generating} {Random} {Numbers} in {Decentralised} {Environments}},
	doi = {10.23919/MIPRO48935.2020.9245302},
	booktitle = {2020 43rd {International} {Convention} on {Information}, {Communication} and {Electronic} {Technology} ({MIPRO})},
	author = {Simić, Srđan Daniel and Šajina, Robert and Tanković, Nikola and Etinger, Darko},
	year = {2020},
	pages = {1668--1673},
}

@article{lesaege_kleros_2020,
	title = {Kleros: {Research} {Challenges} in {Decentralized} {Justice}},
	author = {Lesaege, Clément and George, William and Ast, Federico},
	month = mar,
	year = {2020},
}

@misc{pooltogether_pooltogether_nodate,
	title = {{PoolTogether}},
	url = {https://pooltogether.com},
	abstract = {Win by saving with PoolTogether. The more you save, the more you win!},
	urldate = {2022-02-08},
	journal = {PoolTogether},
	author = {{PoolTogether}},
}

@book{christianson_security_2011,
	address = {Berlin Heidelberg},
	series = {Lecture notes in computer science},
	title = {Security protocols {XVI}: 16th international workshop, {Cambridge}, {UK}, {April} 16-18, 2008 ; revised selected papers},
	isbn = {9783642221378 9783642221361},
	shorttitle = {Security protocols {XVI}},
	language = {eng},
	number = {6615},
	publisher = {Springer},
	editor = {Christianson, Bruce},
	year = {2011},
}
