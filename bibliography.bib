
@misc{noauthor_bitcoin_nodate,
	title = {Bitcoin - {Open} source {P2P} money},
	url = {https://bitcoin.org/en/},
	abstract = {Bitcoin is an innovative payment network and a new kind of money. Find all you need to know and get started with Bitcoin on bitcoin.org.},
	language = {en},
	urldate = {2022-03-21},
}

@misc{noauthor_ethereum_nodate,
	title = {Ethereum},
	url = {https://ethereum.org},
	abstract = {Ethereum is a global, decentralized platform for money and new kinds of applications. On Ethereum, you can write code that controls money, and build applications accessible anywhere in the world.},
	language = {en},
	urldate = {2022-03-21},
	journal = {ethereum.org},
}

@misc{Nakamoto_bitcoin,
	title = {Bitcoin: {A} peer-to-peer electronic cash system,” http://bitcoin.org/bitcoin.pdf},
	author = {Nakamoto, Satoshi},
}

@incollection{RogawayPhillip2004CHBD,
	address = {Berlin, Heidelberg},
	series = {Lecture notes in computer science},
	title = {Cryptographic hash-function basics: {Definitions}, implications, and separations for preimage resistance, second-preimage resistance, and collision resistance},
	isbn = {3-540-22171-9},
	abstract = {We consider basic notions of security for cryptographic hash functions: collision resistance, preimage resistance, and second-preimage resistance. We give seven different definitions that correspond to these three underlying ideas, and then we work out all of the implications and separations among these seven definitions within the concrete-security, provable-security framework. Because our results are concrete, we can show two types of implications, conventional and provisional, where the strength of the latter depends on the amount of compression achieved by the hash function. We also distinguish two types of separations, conditional and unconditional. When constructing counterexamples for our separations, we are careful to preserve specified hash-function domains and ranges; this rules out some pathological counterexamples and makes the separations more meaningful in practice. Four of our definitions are standard while three appear to be new; some of our relations and separations have appeared, others have not. Here we give a modern treatment that acts to catalog, in one place and with carefully-considered nomenclature, the most basic security notions for cryptographic hash functions.},
	language = {english},
	booktitle = {Fast software encryption},
	publisher = {Springer Berlin Heidelberg},
	author = {Rogaway, Phillip and Shrimpton, Thomas},
	year = {2004},
	note = {ISSN: 0302-9743
tex.copyright: Springer-Verlag Berlin Heidelberg 2004},
	keywords = {Applied sciences, Cryptography, Exact sciences and technology, Information, Signal and communications theory, Telecommunications and information theory, collision resistance, cryptographic hash functions, preimage resistance, provable security, second-preimage resistance, signal and communications theory},
	pages = {371--388},
}

@misc{noauthor_sustainable_nodate,
	title = {Sustainable {Blockchain}: {Estimating} the {Carbon} {Footprint} of {Algorand}’s {Pure} {Proof}-of-{Stake}},
	shorttitle = {Sustainable {Blockchain}},
	url = {https://www.algorand.com/resources/blog/sustainable-blockchain-calculating-the-carbon-footprint/},
	abstract = {Pure Proof of Stake offers security, scalability, decentralization and… sustainability!},
	language = {en},
	urldate = {2022-03-18},
}

@misc{noauthor_cambridge_nodate,
	title = {Cambridge {Bitcoin} {Electricity} {Consumption} {Index} ({CBECI})},
	url = {https://ccaf.io/cbeci/index},
	abstract = {The Cambridge Bitcoin Electricity Consumption Index (CBECI) provides a real-time estimate of the total electricity consumption of the Bitcoin network. The CBECI is maintained by the Cambridge Centre for Alternative Finance (CCAF) at Judge Business School, University of Cambridge.},
	language = {en},
	urldate = {2022-03-18},
}

@article{hanke_dfinity_2018,
	title = {{DFINITY} {Technology} {Overview} {Series}, {Consensus} {System}},
	url = {http://arxiv.org/abs/1805.04548},
	abstract = {The DFINITY blockchain computer provides a secure, performant and flexible consensus mechanism. At its core, DFINITY contains a decentralized randomness beacon which acts as a verifiable random function (VRF) that produces a stream of outputs over time. The novel technique behind the beacon relies on the existence of a unique-deterministic, non-interactive, DKG-friendly threshold signatures scheme. The only known examples of such a scheme are pairing-based and derived from BLS. The DFINITY blockchain is layered on top of the DFINITY beacon and uses the beacon as its source of randomness for leader selection and leader ranking. A "weight" is attributed to a chain based on the ranks of the leaders who propose the blocks in the chain, and that weight is used to select between competing chains. The DFINITY blockchain is layered on top of the DFINITY beacon and uses the beacon as its source of randomness for leader selection and leader ranking blockchain is further hardened by a notarization process which dramatically improves the time to finality and eliminates the nothing-at-stake and selfish mining attacks. DFINITY consensus algorithm is made to scale through continuous quorum selections driven by the random beacon. In practice, DFINITY achieves block times of a few seconds and transaction finality after only two confirmations. The system gracefully handles temporary losses of network synchrony including network splits, while it is provably secure under synchrony.},
	urldate = {2022-03-18},
	journal = {arXiv:1805.04548 [cs]},
	author = {Hanke, Timo and Movahedi, Mahnush and Williams, Dominic},
	month = may,
	year = {2018},
	note = {arXiv: 1805.04548},
	keywords = {Computer Science - Distributed, Parallel, and Cluster Computing},
}

@article{fischer_impossibility_1985,
	title = {Impossibility of distributed consensus with one faulty process},
	volume = {32},
	issn = {0004-5411, 1557-735X},
	url = {https://dl.acm.org/doi/10.1145/3149.214121},
	doi = {10.1145/3149.214121},
	abstract = {The consensus problem involves an asynchronous system of processes, some of which may be unreliable. The problem is for the reliable processes to agree on a binary value. In this paper, it is shown that every protocol for this problem has the possibility of nontermination, even with only one faulty process. By way of contrast, solutions are known for the synchronous case, the “Byzantine Generals” problem.},
	language = {en},
	number = {2},
	urldate = {2022-03-17},
	journal = {Journal of the ACM},
	author = {Fischer, Michael J. and Lynch, Nancy A. and Paterson, Michael S.},
	month = apr,
	year = {1985},
	pages = {374--382},
}

@misc{computer_security_division_interoperable_2019,
	title = {Interoperable {Randomness} {Beacons} {\textbar} {CSRC} {\textbar} {CSRC}},
	url = {https://csrc.nist.gov/projects/interoperable-randomness-beacons},
	abstract = {The Interoperable Randomness Beacons project at NIST intends to promote the availability of trusted public randomness as a public utility. This can be used for example for auditability and transparency of services that depend on randomized processes.  The project is spearheaded by the Cryptographic Technology Group in the Computer Security Division of the Information Technology Laboratory (ITL), and has counted with the participation of many collaborators over the years.  WARNING: Do NOT use Beacon generated values as cryptographic secret keys!  The webpage of the NIST Randomness Beacon (with actual random values) is located at: https://beacon.nist.gov/home      Historical notes      Collaborators: Ron Rivest played an important early role in motivating the creation of the project, by pointing out to NIST that a public source of randomness could be valuable for auditing voting machines. Michael Fischer was a valuable early collaborator in thinking about a theoretical framework for public randomness. Andrew...},
	language = {EN-US},
	urldate = {2022-03-17},
	journal = {CSRC {\textbar} NIST},
	author = {Computer Security Division, Information Technology Laboratory},
	month = jun,
	year = {2019},
}

@article{wesolowski_efficient_2020,
	title = {Efficient {Verifiable} {Delay} {Functions}},
	volume = {33},
	issn = {1432-1378},
	url = {https://doi.org/10.1007/s00145-020-09364-x},
	doi = {10.1007/s00145-020-09364-x},
	abstract = {We construct a verifiable delay function (VDF). A VDF is a function whose evaluation requires running a given number of sequential steps, yet the result can be efficiently verified. They have applications in decentralised systems, such as the generation of trustworthy public randomness in a trustless environment, or resource-efficient blockchains. To construct our VDF, we actually build a trapdoor VDF. A trapdoor VDF is essentially a VDF which can be evaluated efficiently by parties who know a secret (the trapdoor). By setting up this scheme in a way that the trapdoor is unknown (not even by the party running the setup, so that there is no need for a trusted setup environment), we obtain a simple VDF. Our construction is based on groups of unknown order such as an RSA group or the class group of an imaginary quadratic field. The output of our construction is very short (the result and the proof of correctness are each a single element of the group), and the verification of correctness is very efficient.},
	language = {en},
	number = {4},
	urldate = {2022-03-15},
	journal = {Journal of Cryptology},
	author = {Wesolowski, Benjamin},
	month = oct,
	year = {2020},
	pages = {2113--2147},
}

@techreport{10.5555/888615,
	address = {USA},
	title = {Time-lock puzzles and timed-release crypto},
	abstract = {Our motivation is the notion of “timed-release crypto,”” where the goal is to encrypt a message so that it can not be decrypted by anyone, not even the sender, until a pre-determined amount of time has passed. The goal is to “send information into the future.”” This problem was first discussed by Timothy May citeMay93. What are the applications of “timed-release crypto””? Here are a few possibilities (some due to May): A bidder in an auction wants to seal his bid so that it can only be opened after the bidding period is closed. A homeowner wants to give his mortgage holder a series of encrypted mortgage payments. These might be encrypted digital cash with different decryption dates, so that one payment becomes decryptable (and thus usable by the bank) at the beginning of each successive month. An individual wants to encrypt his diaries so that they are only decryptable after fifty years. A key-escrow scheme can be based on timed-release crypto, so that the government can get the message keys, but only after a fixed period (say one year). There are presumably many other applications. There are two natural approaches to implementing timed-release crypto: Use “time-lock puzzles””–computational problems that can not be solved without running a computer continuously for at least a certain amount of time. Use trusted agents who promise not to reveal certain information until a specified date. Using trusted agents has the obvious problem of ensuring that the agents are trustworthy; secret-sharing approaches can be used to alleviate this concern. Using time-lock puzzles has the problem that the CPU time required to solve a problem can depend on the amount and nature of the hardware used to solve the problem, as well as the parallelizability of the computational problem being solved. In this note we explore both approaches. (We note that Tim May has suggested an approach based on the use of trusted agents.)},
	institution = {Massachusetts Institute of Technology},
	author = {Rivest, R. L. and Shamir, A. and Wagner, D. A.},
	year = {1996},
}

@techreport{rivest_time-lock_1996,
	address = {USA},
	type = {Technical {Report}},
	title = {Time-lock {Puzzles} and {Timed}-release {Crypto}},
	abstract = {Our motivation is the notion of ``timed-release crypto,'''' where the goal is to encrypt a message so that it can not be decrypted by anyone, not even the sender, until a pre-determined amount of time has passed. The goal is to ``send information into the future.'''' This problem was first discussed by Timothy May {\textbackslash}cite\{May93\}. What are the applications of ``timed-release crypto''''? Here are a few possibilities (some due to May): A bidder in an auction wants to seal his bid so that it can only be opened after the bidding period is closed. A homeowner wants to give his mortgage holder a series of encrypted mortgage payments. These might be encrypted digital cash with different decryption dates, so that one payment becomes decryptable (and thus usable by the bank) at the beginning of each successive month. An individual wants to encrypt his diaries so that they are only decryptable after fifty years. A key-escrow scheme can be based on timed-release crypto, so that the government can get the message keys, but only after a fixed period (say one year). {\textbackslash} There are presumably many other applications. There are two natural approaches to implementing timed-release crypto: Use ``time-lock puzzles''''--computational problems that can not be solved without running a computer continuously for at least a certain amount of time. Use trusted agents who promise not to reveal certain information until a specified date. Using trusted agents has the obvious problem of ensuring that the agents are trustworthy; secret-sharing approaches can be used to alleviate this concern. Using time-lock puzzles has the problem that the CPU time required to solve a problem can depend on the amount and nature of the hardware used to solve the problem, as well as the parallelizability of the computational problem being solved. In this note we explore both approaches. (We note that Tim May has suggested an approach based on the use of trusted agents.)},
	institution = {Massachusetts Institute of Technology},
	author = {Rivest, R. L. and Shamir, A. and Wagner, D. A.},
	year = {1996},
}

@book{bertino_computer_2021,
	address = {Cham, Switzerland},
	series = {Lecture notes in computer science},
	title = {Computer security – {ESORICS} 2021: 26th {European} {Symposium} on {Research} in {Computer} {Security}, {Darmstadt}, {Germany}, {October} 4–8, 2021: proceedings. {Part} 2},
	isbn = {9783030884277},
	shorttitle = {Computer security – {ESORICS} 2021},
	language = {eng},
	number = {12973},
	publisher = {Springer},
	editor = {Bertino, Elisa and Shulman, Haya and Waidner, Michael},
	year = {2021},
}

@inproceedings{10.1145/12130.12168,
	address = {New York, NY, USA},
	series = {{STOC} '86},
	title = {Limits on the security of coin flips when half the processors are faulty},
	isbn = {0-89791-193-8},
	url = {https://doi-org.libproxy.helsinki.fi/10.1145/12130.12168},
	doi = {10.1145/12130.12168},
	booktitle = {Proceedings of the eighteenth annual {ACM} symposium on theory of computing},
	publisher = {Association for Computing Machinery},
	author = {Cleve, R},
	year = {1986},
	note = {Number of pages: 6
Place: Berkeley, California, USA},
	pages = {364--369},
}

@inproceedings{micali_verifiable_1999,
	title = {Verifiable random functions},
	doi = {10.1109/SFFCS.1999.814584},
	booktitle = {40th {Annual} {Symposium} on {Foundations} of {Computer} {Science} ({Cat}. {No}.{99CB37039})},
	author = {Micali, S. and Rabin, M. and Vadhan, S.},
	year = {1999},
	pages = {120--130},
}

@article{goldreich_how_1986,
	title = {How to {Construct} {Random} {Functions}},
	volume = {33},
	issn = {0004-5411},
	url = {https://doi.org/10.1145/6490.6503},
	doi = {10.1145/6490.6503},
	abstract = {A constructive theory of randomness for functions, based on computational complexity, is developed, and a pseudorandom function generator is presented. This generator is a deterministic polynomial-time algorithm that transforms pairs (g, r), where g is any one-way function and r is a random k-bit string, to polynomial-time computable functions undefinedr: 1, … , 2k → 1, … , 2k. These undefinedr's cannot be distinguished from random functions by any probabilistic polynomial-time algorithm that asks and receives the value of a function at arguments of its choice. The result has applications in cryptography, random constructions, and complexity theory.},
	number = {4},
	journal = {J. ACM},
	author = {Goldreich, Oded and Goldwasser, Shafi and Micali, Silvio},
	month = aug,
	year = {1986},
	note = {Place: New York, NY, USA
Publisher: Association for Computing Machinery},
	pages = {792--807},
}

@inproceedings{gilad_algorand_2017,
	address = {New York, NY, USA},
	series = {{SOSP} '17},
	title = {Algorand: {Scaling} {Byzantine} {Agreements} for {Cryptocurrencies}},
	isbn = {978-1-4503-5085-3},
	url = {https://doi.org/10.1145/3132747.3132757},
	doi = {10.1145/3132747.3132757},
	abstract = {Algorand is a new cryptocurrency that confirms transactions with latency on the order of a minute while scaling to many users. Algorand ensures that users never have divergent views of confirmed transactions, even if some of the users are malicious and the network is temporarily partitioned. In contrast, existing cryptocurrencies allow for temporary forks and therefore require a long time, on the order of an hour, to confirm transactions with high confidence.Algorand uses a new Byzantine Agreement (BA) protocol to reach consensus among users on the next set of transactions. To scale the consensus to many users, Algorand uses a novel mechanism based on Verifiable Random Functions that allows users to privately check whether they are selected to participate in the BA to agree on the next set of transactions, and to include a proof of their selection in their network messages. In Algorand's BA protocol, users do not keep any private state except for their private keys, which allows Algorand to replace participants immediately after they send a message. This mitigates targeted attacks on chosen participants after their identity is revealed.We implement Algorand and evaluate its performance on 1,000 EC2 virtual machines, simulating up to 500,000 users. Experimental results show that Algorand confirms transactions in under a minute, achieves 125x Bitcoin's throughput, and incurs almost no penalty for scaling to more users.},
	booktitle = {Proceedings of the 26th {Symposium} on {Operating} {Systems} {Principles}},
	publisher = {Association for Computing Machinery},
	author = {Gilad, Yossi and Hemo, Rotem and Micali, Silvio and Vlachos, Georgios and Zeldovich, Nickolai},
	year = {2017},
	note = {event-place: Shanghai, China},
	pages = {51--68},
}

@article{shamir_how_1979,
	title = {How to {Share} a {Secret}},
	volume = {22},
	issn = {0001-0782},
	url = {https://doi.org/10.1145/359168.359176},
	doi = {10.1145/359168.359176},
	abstract = {In this paper we show how to divide data D into n pieces in such a way that D is easily reconstructable from any k pieces, but even complete knowledge of k - 1 pieces reveals absolutely no information about D. This technique enables the construction of robust key management schemes for cryptographic systems that can function securely and reliably even when misfortunes destroy half the pieces and security breaches expose all but one of the remaining pieces.},
	number = {11},
	journal = {Commun. ACM},
	author = {Shamir, Adi},
	month = nov,
	year = {1979},
	note = {Place: New York, NY, USA
Publisher: Association for Computing Machinery},
	keywords = {cryptography, interpolation, key management},
	pages = {612--613},
}

@article{goldwasser_knowledge_1989,
	title = {The {Knowledge} {Complexity} of {Interactive} {Proof} {Systems}},
	volume = {18},
	url = {https://www.proquest.com/scholarly-journals/knowledge-complexity-interactive-proof-systems/docview/919784312/se-2},
	abstract = {Usually, a proof of a theorem contains more knowledge than the mere fact that the theorem is true. For instance, to prove that a graph is Hamiltonian it suffices to exhibit a Hamiltonian tour in it; however, this seems to contain more knowledge than the single bit Hamiltonian/non-Hamiltonian. In this paper a computational complexity theory of the "knowledge" contained in a proof is developed. Zero-knowledge proofs are defined as those proofs that convey no additional knowledge other than the correctness of the proposition in question. Examples of zero-knowledge proof systems are given for the languages of quadratic residuosity and 'quadratic nonresiduosity. These are the first examples of zero-knowledge proofs for languages not known to be efficiently recognizable.},
	language = {English},
	number = {1},
	journal = {SIAM Journal on Computing},
	author = {Goldwasser, Shafi and Micali, Silvio and Rackoff, Charles},
	month = feb,
	year = {1989},
	note = {ISBN: 00975397},
	keywords = {Algorithms, Coins, Computer science, Knowledge, Language, Mathematics, Probability distribution},
	pages = {186--23},
}

@book{noauthor_stabilization_2017,
	address = {New York, NY},
	title = {Stabilization, safety, and security of distributed systems},
	isbn = {9783319690834},
	publisher = {Springer Berlin Heidelberg},
	year = {2017},
}

@article{dharanikota_breeding_2020,
	title = {Breeding unicorns: {Developing} trustworthy and scalable randomness beacons},
	volume = {15},
	issn = {1932-6203},
	shorttitle = {Breeding unicorns},
	url = {https://dx.plos.org/10.1371/journal.pone.0232261},
	doi = {10.1371/journal.pone.0232261},
	language = {en},
	number = {4},
	urldate = {2022-03-14},
	journal = {PLOS ONE},
	author = {Dharanikota, Samvid and Jensen, Michael Toft and Kristensen, Sebastian Rom and Michno, Mathias Sass and Pignolet, Yvonne-Anne and Rydhof Hansen, René and Schmid, Stefan},
	editor = {Debiao, He},
	month = apr,
	year = {2020},
	pages = {e0232261},
}

@article{cachin_random_2005,
	title = {Random {Oracles} in {Constantinople}: {Practical} {Asynchronous} {Byzantine} {Agreement} {Using} {Cryptography}},
	volume = {18},
	issn = {0933-2790, 1432-1378},
	shorttitle = {Random {Oracles} in {Constantinople}},
	url = {http://link.springer.com/10.1007/s00145-005-0318-0},
	doi = {10.1007/s00145-005-0318-0},
	language = {en},
	number = {3},
	urldate = {2022-03-14},
	journal = {Journal of Cryptology},
	author = {Cachin, Christian and Kursawe, Klaus and Shoup, Victor},
	month = jul,
	year = {2005},
	pages = {219--246},
}

@article{rabin_transaction_1983,
	title = {Transaction protection by beacons},
	volume = {27},
	issn = {0022-0000},
	url = {https://www.sciencedirect.com/science/article/pii/0022000083900429},
	doi = {10.1016/0022-0000(83)90042-9},
	abstract = {Protocols for implementing contract signing, confidential disclosures, and certified mail in an electronic mail system are proposed. These transactions are provably impossible without a trusted intermediary. However, they can be implemented with just a small probability of a participant cheating his partner, by use of a beacon emitting random integers. Applications include privacy protection of personal information in data banks, as well as the protection of business transactions.},
	language = {en},
	number = {2},
	urldate = {2022-03-14},
	journal = {Journal of Computer and System Sciences},
	author = {Rabin, Michael O.},
	month = oct,
	year = {1983},
	pages = {256--267},
}

@techreport{lenstra_random_2015,
	title = {A random zoo: sloth, unicorn, and trx},
	shorttitle = {A random zoo},
	url = {https://eprint.iacr.org/2015/366},
	abstract = {Many applications require trustworthy generation of public random numbers. It is shown how this can be achieved using a hash function that is timed to be as slow as desired (sloth), while the correctness of the resulting hash can be verified quickly. It is shown how sloth can be used for uncontestable random number generation (unicorn), and how unicorn can be used for a new trustworthy random elliptic curves service (trx) and random-sample voting.},
	number = {366},
	urldate = {2022-03-14},
	author = {Lenstra, Arjen K. and Wesolowski, Benjamin},
	year = {2015},
	keywords = {random-sample voting, slow-times hash, trustworthy random elliptic curves service, uncontestable random numbers},
}

@misc{corrigan-gibbs_ensuring_2014,
	title = {Ensuring {High}-{Quality} {Randomness} in {Cryptographic} {Key} {Generation}},
	author = {Corrigan-Gibbs, Henry and Mu, Wendy and Boneh, Dan and Ford, Bryan},
	year = {2014},
	note = {\_eprint: 1309.7366},
}

@misc{noauthor_hard_nodate,
	title = {Hard {Problems} of {Cryptocurrency} 2015},
	url = {https://eth.wiki/en/ideas/hpoc_2015},
	language = {en},
	urldate = {2022-02-08},
	journal = {Ethereum Wiki},
}

@misc{ethereum_foundation_ethereum_nodate,
	title = {Ethereum},
	url = {https://ethereum.org},
	abstract = {Ethereum is a global, decentralized platform for money and new kinds of applications. On Ethereum, you can write code that controls money, and build applications accessible anywhere in the world.},
	language = {en},
	urldate = {2022-02-13},
	journal = {ethereum.org},
	author = {Ethereum Foundation},
}

@inproceedings{boneh_verifiable_2018,
	series = {Lecture {Notes} in {Computer} {Science} (including subseries {Lecture} {Notes} in {Artificial} {Intelligence} and {Lecture} {Notes} in {Bioinformatics})},
	title = {Verifiable delay functions},
	isbn = {978-3-319-96883-4},
	doi = {10.1007/978-3-319-96884-1_25},
	abstract = {We study the problem of building a verifiable delay function (VDF). A VDF requires a specified number of sequential steps to evaluate, yet produces a unique output that can be efficiently and publicly verified. VDF s have many applications in decentralized systems, including public randomness beacons, leader election in consensus protocols, and proofs of replication. We formalize the requirements for VDF s and present new candidate constructions that are the first to achieve an exponential gap between evaluation and verification time.},
	language = {English (US)},
	booktitle = {Advances in {Cryptology} – {CRYPTO} 2018 - 38th {Annual} {International} {Cryptology} {Conference}, 2018, {Proceedings}},
	publisher = {Springer Verlag},
	author = {Boneh, Dan and Bonneau, Joseph and Bünz, Benedikt and Fisch, Ben},
	editor = {Boldyreva, Alexandra and Shacham, Hovav},
	year = {2018},
	pages = {757--788},
}

@inproceedings{syta_scalable_2017,
	title = {Scalable {Bias}-{Resistant} {Distributed} {Randomness}},
	doi = {10.1109/SP.2017.45},
	booktitle = {2017 {IEEE} {Symposium} on {Security} and {Privacy} ({SP})},
	author = {Syta, Ewa and Jovanovic, Philipp and Kogias, Eleftherios Kokoris and Gailly, Nicolas and Gasser, Linus and Khoffi, Ismail and Fischer, Michael J. and Ford, Bryan},
	year = {2017},
	pages = {444--460},
}

@misc{noauthor_verifiable_2020,
	title = {Verifiable {Randomness} for {Blockchain} {Smart} {Contracts}},
	url = {https://blog.chain.link/chainlink-vrf-on-chain-verifiable-randomness/},
	abstract = {Chainlink VRF (Verifiable Randomness Function) allows blockchain developers to easily add verifiable randomness to their smart contracts.},
	language = {en-US},
	urldate = {2022-02-09},
	journal = {Chainlink Blog},
	month = may,
	year = {2020},
}

@inproceedings{simic_review_2020,
	title = {A {Review} on {Generating} {Random} {Numbers} in {Decentralised} {Environments}},
	doi = {10.23919/MIPRO48935.2020.9245302},
	booktitle = {2020 43rd {International} {Convention} on {Information}, {Communication} and {Electronic} {Technology} ({MIPRO})},
	author = {Simić, Srđan Daniel and Šajina, Robert and Tanković, Nikola and Etinger, Darko},
	year = {2020},
	pages = {1668--1673},
}

@article{lesaege_kleros_2020,
	title = {Kleros: {Research} {Challenges} in {Decentralized} {Justice}},
	author = {Lesaege, Clément and George, William and Ast, Federico},
	month = mar,
	year = {2020},
}

@misc{pooltogether_pooltogether_nodate,
	title = {{PoolTogether}},
	url = {https://pooltogether.com},
	abstract = {Win by saving with PoolTogether. The more you save, the more you win!},
	urldate = {2022-02-08},
	journal = {PoolTogether},
	author = {{PoolTogether}},
}

@book{christianson_security_2011,
	address = {Berlin Heidelberg},
	series = {Lecture notes in computer science},
	title = {Security protocols {XVI}: 16th international workshop, {Cambridge}, {UK}, {April} 16-18, 2008 ; revised selected papers},
	isbn = {9783642221378 9783642221361},
	shorttitle = {Security protocols {XVI}},
	language = {eng},
	number = {6615},
	publisher = {Springer},
	editor = {Christianson, Bruce},
	year = {2011},
}
