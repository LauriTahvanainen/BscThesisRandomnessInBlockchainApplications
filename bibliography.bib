
@incollection{alma9932206893506253,
	address = {Cambridge ;},
	title = {Computational complexity : a conceptual perspective},
	isbn = {0-511-40077-2},
	abstract = {Complexity theory is a central field of the theoretical foundations of computer science, concerned with the general study of the intrinsic complexity of computational tasks. This book offers a conceptual perspective on complexity theory intended to serve as an introduction for advanced undergraduates and graduates.},
	booktitle = {Computational complexity : a conceptual perspective},
	publisher = {Cambridge University Press},
	author = {Goldreich, Oded.},
	year = {2008},
	keywords = {Computational complexity},
	pages = {283--348},
}

@article{NguyenCongT2019PCMf,
	title = {Proof-of-stake consensus mechanisms for future blockchain networks: {Fundamentals}, applications and opportunities},
	volume = {7},
	issn = {2169-3536},
	abstract = {The rapid development of blockchain technology and their numerous emerging applications has received huge attention in recent years. The distributed consensus mechanism is the backbone of a blockchain network. It plays a key role in ensuring the network's security, integrity, and performance. Most current blockchain networks have been deploying the proof-of-work consensus mechanisms, in which the consensus is reached through intensive mining processes. However, this mechanism has several limitations, e.g., energy inefficiency, delay, and vulnerable to security threats. To overcome these problems, a new consensus mechanism has been developed recently, namely proof of stake, which enables to achieve the consensus via proving the stake ownership. This mechanism is expected to become a cutting-edge technology for future blockchain networks. This paper is dedicated to investigating proof-of-stake mechanisms, from fundamental knowledge to advanced proof-of-stake-based protocols along with performance analysis, e.g., energy consumption, delay, and security, as well as their promising applications, particularly in the field of Internet of Vehicles. The formation of stake pools and their effects on the network stake distribution are also analyzed and simulated. The results show that the ratio between the block reward and the total network stake has a significant impact on the decentralization of the network. Technical challenges and potential solutions are also discussed.},
	journal = {IEEE access : practical innovations, open solutions},
	author = {Nguyen, Cong T and Hoang, Dinh Thai and Nguyen, Diep N and Niyato, Dusit and Nguyen, Huynh Tuong and Dutkiewicz, Eryk},
	year = {2019},
	keywords = {Blockchain, Cryptography, Delays, Distributed databases, Energy consumption, Games, Hash functions, Internet of Vehicles, Networks, Protocol (computers), Security, and mining process, consensus mechanisms, energy, game theory, proof-of-stake, proof-of-work},
	pages = {85727--85745},
}

@inproceedings{MerlinChains,
	title = {Cryptocurrency smart contracts for distributed consensus of public randomness},
	doi = {https://doi.org/10.1007/978-3-319-69084-1_31},
	publisher = {Proceedings of the 19th International Symposium on Stabilization, Safety, and Security of Distributed Systems, Boston, MA},
	author = {Mell, Peter and Kelsey, John and Shook, James},
	year = {2017},
}

@article{hanke_dfinity_2018,
	title = {{DFINITY} {Technology} {Overview} {Series}, {Consensus} {System}},
	url = {http://arxiv.org/abs/1805.04548},
	abstract = {The DFINITY blockchain computer provides a secure, performant and flexible consensus mechanism. At its core, DFINITY contains a decentralized randomness beacon which acts as a verifiable random function (VRF) that produces a stream of outputs over time. The novel technique behind the beacon relies on the existence of a unique-deterministic, non-interactive, DKG-friendly threshold signatures scheme. The only known examples of such a scheme are pairing-based and derived from BLS. The DFINITY blockchain is layered on top of the DFINITY beacon and uses the beacon as its source of randomness for leader selection and leader ranking. A "weight" is attributed to a chain based on the ranks of the leaders who propose the blocks in the chain, and that weight is used to select between competing chains. The DFINITY blockchain is layered on top of the DFINITY beacon and uses the beacon as its source of randomness for leader selection and leader ranking blockchain is further hardened by a notarization process which dramatically improves the time to finality and eliminates the nothing-at-stake and selfish mining attacks. DFINITY consensus algorithm is made to scale through continuous quorum selections driven by the random beacon. In practice, DFINITY achieves block times of a few seconds and transaction finality after only two confirmations. The system gracefully handles temporary losses of network synchrony including network splits, while it is provably secure under synchrony.},
	urldate = {2022-03-18},
	author = {Hanke, Timo and Movahedi, Mahnush and Williams, Dominic},
	month = may,
	year = {2018},
	keywords = {Computer Science - Distributed, Parallel, and Cluster Computing},
}

@inproceedings{gilad_algorand_2017,
	address = {New York, NY, USA},
	series = {{SOSP} '17},
	title = {Algorand: {Scaling} {Byzantine} {Agreements} for {Cryptocurrencies}},
	isbn = {978-1-4503-5085-3},
	url = {https://doi.org/10.1145/3132747.3132757},
	doi = {10.1145/3132747.3132757},
	abstract = {Algorand is a new cryptocurrency that confirms transactions with latency on the order of a minute while scaling to many users. Algorand ensures that users never have divergent views of confirmed transactions, even if some of the users are malicious and the network is temporarily partitioned. In contrast, existing cryptocurrencies allow for temporary forks and therefore require a long time, on the order of an hour, to confirm transactions with high confidence.Algorand uses a new Byzantine Agreement (BA) protocol to reach consensus among users on the next set of transactions. To scale the consensus to many users, Algorand uses a novel mechanism based on Verifiable Random Functions that allows users to privately check whether they are selected to participate in the BA to agree on the next set of transactions, and to include a proof of their selection in their network messages. In Algorand's BA protocol, users do not keep any private state except for their private keys, which allows Algorand to replace participants immediately after they send a message. This mitigates targeted attacks on chosen participants after their identity is revealed.We implement Algorand and evaluate its performance on 1,000 EC2 virtual machines, simulating up to 500,000 users. Experimental results show that Algorand confirms transactions in under a minute, achieves 125x Bitcoin's throughput, and incurs almost no penalty for scaling to more users.},
	booktitle = {Proceedings of the 26th {Symposium} on {Operating} {Systems} {Principles}},
	publisher = {Association for Computing Machinery},
	author = {Gilad, Yossi and Hemo, Rotem and Micali, Silvio and Vlachos, Georgios and Zeldovich, Nickolai},
	year = {2017},
	pages = {51--68},
}

@article{10.1145/1008908.1008911,
	title = {Coin flipping by telephone a protocol for solving impossible problems},
	volume = {15},
	issn = {0163-5700},
	url = {https://doi.org/10.1145/1008908.1008911},
	doi = {10.1145/1008908.1008911},
	abstract = {Alice and Bob want to flip a coin by telephone. (They have just divorced, live in different cities, want to decide who gets the car.) Bob would not like to tell Alice HEADS and hear Alice (at the other end of the line) say "Here goes . . . I'm flipping the coin. . . . You lost!"Coin-flipping in the SPECIAL way done here has a serious purpose. Indeed, it should prove an INDISPENSABLE TOOL of the protocol designer. Whenever a protocol requires one of two adversaries, say Alice, to pick a sequence of bits at random, and whenever it serves Alice's interests best NOT to pick her sequence of bits at random, then coin-flipping (Bob flipping coins to Alice) as defined here achieves the desired goal:1. It GUARANTEES to Bob that Alice will pick her sequence of bits at random. Her bit is 1 if Bob flips heads to her, O otherwise.2. It GUARANTEES to Alice that Bob will not know WHAT sequence of bits he flipped to her.Coin-flipping has already proved useful in solving a number of problems once thought impossible: mental poker, certified mail, and exchange of secrets. It will certainly prove a useful tool in solving other problems as well.},
	number = {1},
	journal = {SIGACT News},
	author = {Blum, Manuel},
	month = jan,
	year = {1983},
	pages = {23--27},
}

@inproceedings{boneh2001short,
	title = {Short signatures from the {Weil} pairing},
	booktitle = {International conference on the theory and application of cryptology and information security},
	author = {Boneh, Dan and Lynn, Ben and Shacham, Hovav},
	year = {2001},
	pages = {514--532},
}

@article{wood2014ethereum,
	title = {Ethereum: {A} secure decentralised generalised transaction ledger},
	url = {https://ethereum.github.io/yellowpaper/paper.pdf},
	urldate = {2022-05-08},
	author = {Wood, Gavin},
}

@article{8760539,
	title = {A vademecum on blockchain technologies: {When}, which, and how},
	volume = {21},
	doi = {10.1109/COMST.2019.2928178},
	number = {4},
	journal = {IEEE Communications Surveys Tutorials},
	author = {Belotti, Marianna and Božić, Nikola and Pujolle, Guy and Secci, Stefano},
	year = {2019},
	pages = {3796--3838},
}

@misc{noauthor_decentralized_nodate,
	title = {Decentralized finance ({DeFi})},
	url = {https://ethereum.org},
	abstract = {An overview of DeFi on Ethereum},
	language = {en},
	urldate = {2022-05-03},
	journal = {ethereum.org},
}

@misc{noauthor_medibloc_nodate,
	title = {{MediBloc} {Limited} - {Own} your health data. {It}'s rightfully yours.},
	url = {https://medibloc.com/en/},
	abstract = {MediBloc is creating a patient-centered health data ecosystem that can protect individual privacy and maximize the reliability of health data by developing ‘Panacea’, a high-performance blockchain optimized for health data exchange.},
	language = {en-US},
	urldate = {2022-05-03},
	journal = {MediBloc Limited},
}

@misc{noauthor_state_nodate,
	title = {State of the {DApps} — {DApp} {Statistics}},
	url = {https://www.stateofthedapps.com/stats},
	abstract = {Total DApps, Daily Active Users, DApps by Category and more...},
	language = {en-US},
	urldate = {2022-05-03},
}

@misc{noauthor_proof_nodate,
	title = {Proof {Of} {Humanity}},
	url = {https://www.proofofhumanity.id/},
	abstract = {A system combining social verification with video submission to create a Sybil-proof list of humans.},
	urldate = {2022-04-29},
}

@misc{noauthor_chainlink_nodate,
	title = {Chainlink {Documentation}},
	url = {https://docs.chain.link/},
	abstract = {Chainlink is the most widely used oracle network for powering universally connected smart contracts, enabling any blockchain to access real-world data \& APIs.},
	urldate = {2022-04-29},
}

@book{alma9928100443506253,
	address = {Cham},
	series = {{SpringerBriefs} in computer science},
	title = {Homomorphic encryption and applications},
	isbn = {3-319-12229-0},
	abstract = {This book introduces the fundamental concepts of homomorphic encryption. From these foundations, applications are developed in the fields of private information retrieval, private searching on streaming data, privacy-preserving data mining, electronic voting and cloud computing. The content is presented in an instructional and practical style, with concrete examples to enhance the reader's understanding. This volume achieves a balance between the theoretical and the practical components of modern information security. Readers will learn key principles of homomorphic encryption as well as their application in solving real world problems.},
	publisher = {Springer},
	author = {Yi, Xun},
	year = {2014},
	keywords = {Data encryption (Computer science)},
}

@incollection{StadlerMarkus2001PVSS,
	address = {Berlin, Heidelberg},
	series = {Lecture notes in computer science},
	title = {Publicly verifiable secret sharing},
	isbn = {3-540-61186-X},
	abstract = {A secret sharing scheme allows to share a secret among several participants such that only certain groups of them can recover it. Verifiable secret sharing has been proposed to achieve security against cheating participants. Its first realization had the special property that everybody, not only the participants, can verify that the shares are cor- rectly distributed. We will call such schemes publicly verifiable secret sharing schemes, we discuss new applications to escrow cryptosystems and to payment systems with revocable anonymity, and we present two new realizations based on ElGamal’s cryptosystem.},
	booktitle = {Advances in cryptology — {EUROCRYPT} ’96},
	publisher = {Springer Berlin Heidelberg},
	author = {Stadler, Markus},
	year = {2001},
	note = {ISSN: 0302-9743},
	keywords = {Access Structure, Discrete Logarithm, Secret Sharing, Secret Sharing Scheme, Signature Scheme},
	pages = {190--199},
}

@inproceedings{pedersen1991threshold,
	title = {A threshold cryptosystem without a trusted party},
	booktitle = {Workshop on the theory and application of of cryptographic techniques},
	author = {Pedersen, Torben Pryds},
	year = {1991},
	note = {Springer},
	pages = {522--526},
}

@inproceedings{douceur2002sybil,
	title = {The sybil attack},
	booktitle = {International workshop on peer-to-peer systems},
	author = {Douceur, John R},
	year = {2002},
	note = {Springer},
	pages = {251--260},
}

@article{Caucus,
	title = {Winning the caucus race: {Continuous} leader election via public randomness},
	volume = {abs/1801.07965},
	url = {http://arxiv.org/abs/1801.07965},
	journal = {CoRR},
	author = {Azouvi, Sarah and McCorry, Patrick and Meiklejohn, Sarah},
	year = {2018},
}

@inproceedings{gennaro1999secure,
	title = {Secure distributed key generation for discrete-log based cryptosystems},
	booktitle = {International conference on the theory and applications of cryptographic techniques},
	author = {Gennaro, Rosario and Jarecki, Stanisław and Krawczyk, Hugo and Rabin, Tal},
	year = {1999},
	note = {tex.organization: Springer},
	pages = {295--310},
}

@article{schindler2019ethdkg,
	title = {Ethdkg: {Distributed} key generation with ethereum smart contracts},
	journal = {Cryptology ePrint Archive},
	author = {Schindler, Philipp and Judmayer, Aljosha and Stifter, Nicholas and Weippl, Edgar},
	year = {2019},
}

@article{papadopoulos2017making,
	title = {Making {NSEC5} practical for {DNSSEC}},
	journal = {Cryptology ePrint Archive},
	author = {Papadopoulos, Dimitrios and Wessels, Duane and Huque, Shumon and Naor, Moni and Včelák, Jan and Reyzin, Leonid and Goldberg, Sharon},
	year = {2017},
}

@misc{noauthor_vrf_nodate,
	title = {{VRF} {Security} {Considerations} {\textbar} {Chainlink} {Documentation}},
	url = {https://docs.chain.link/docs/vrf-security-considerations/},
	urldate = {2022-04-18},
}

@inproceedings{cascudo2017scrape,
	title = {{SCRAPE}: {Scalable} randomness attested by public entities},
	booktitle = {International conference on applied cryptography and network security},
	author = {Cascudo, Ignacio and David, Bernardo},
	year = {2017},
	note = {tex.organization: Springer},
	pages = {537--556},
}

@article{bhat2022optrand,
	title = {{OptRand}: {Optimistically} responsive distributed random beacons},
	journal = {Cryptology ePrint Archive},
	author = {Bhat, Adithya and Kate, Aniket and Nayak, Kartik and Shrestha, Nibesh},
	year = {2022},
}

@article{cascudo2021mt,
	title = {Mt. {Random}: {Multi}-tiered randomness beacons},
	journal = {Cryptology ePrint Archive},
	author = {Cascudo, Ignacio and David, Bernardo and Shlomovits, Omer and Varlakov, Denis},
	year = {2021},
}

@article{cherniaeva2019homomorphic,
	title = {Homomorphic encryption random beacon},
	journal = {Cryptology ePrint Archive},
	author = {Cherniaeva, Alisa and Shirobokov, Ilia and Shlomovits, Omer},
	year = {2019},
}

@article{schindler2021randrunner,
	title = {Randrunner: {Distributed} randomness from trapdoor vdfs with strong uniqueness},
	author = {Schindler, Philipp and Judmayer, Aljosha and Hittmeir, Markus and Stifter, Nicholas and Weippl, Edgar},
	year = {2021},
}

@article{han2020randchain,
	title = {{RandChain}: {Decentralised} randomness beacon from sequential proof-of-work.},
	volume = {2020},
	journal = {IACR Cryptol. ePrint Arch.},
	author = {Han, Runchao and Yu, Jiangshan and Lin, Haoyu},
	year = {2020},
	pages = {1033},
}

@inproceedings{bhat2021randpiper,
	title = {Randpiper–reconfiguration-friendly random beacons with quadratic communication},
	booktitle = {Proceedings of the 2021 {ACM} {SIGSAC} conference on computer and communications security},
	author = {Bhat, Adithya and Shrestha, Nibesh and Luo, Zhongtang and Kate, Aniket and Nayak, Kartik},
	year = {2021},
	pages = {3502--3524},
}

@inproceedings{cascudo2020albatross,
	title = {{ALBATROSS}: publicly attestable batched randomness based on secret sharing},
	booktitle = {International conference on the theory and application of cryptology and information security},
	author = {Cascudo, Ignacio and David, Bernardo},
	year = {2020},
	note = {tex.organization: Springer},
	pages = {311--341},
}

@misc{Nakamoto_bitcoin,
	title = {Bitcoin: {A} peer-to-peer electronic cash system},
	url = {http://bitcoin.org/bitcoin.pdf},
	author = {Nakamoto, Satoshi},
}

@inproceedings{schindler_hydrand_2020,
	title = {{HydRand}: {Efficient} {Continuous} {Distributed} {Randomness}},
	shorttitle = {{HydRand}},
	doi = {10.1109/SP40000.2020.00003},
	abstract = {A reliable source of randomness is not only an essential building block in various cryptographic, security, and distributed systems protocols, but also plays an integral part in the design of many new blockchain proposals. Consequently, the topic of publicly-verifiable, bias-resistant and unpredictable randomness has recently enjoyed increased attention. In particular random beacon protocols, aimed at continuous operation, can be a vital component for current Proof-of-Stake based distributed ledger proposals. We improve upon previous random beacon approaches with HydRand, a novel distributed protocol based on publicly-verifiable secret sharing (PVSS) to ensure unpredictability, bias-resistance, and public-verifiability of a continuous sequence of random beacon values. Furthermore, HydRand provides guaranteed output delivery of randomness at regular and predictable intervals in the presence of adversarial behavior and does not rely on a trusted dealer for the initial setup. Compared to existing PVSS based approaches that strive to achieve similar properties, our solution improves scalability by lowering the communication complexity from \${\textbackslash}mathcalO{\textbackslash}left( n{\textasciicircum}3 {\textbackslash}right)\$ to \${\textbackslash}mathcalO{\textbackslash}left( n{\textasciicircum}2 {\textbackslash}right)\$ . Furthermore, we are the first to present a detailed comparison of recently described schemes and protocols that can be used for implementing random beacons.},
	booktitle = {2020 {IEEE} {Symposium} on {Security} and {Privacy} ({SP})},
	author = {Schindler, Philipp and Judmayer, Aljosha and Stifter, Nicholas and Weippl, Edgar},
	month = may,
	year = {2020},
	note = {ISSN: 2375-1207},
	keywords = {Proposals, Protocols, Public key},
	pages = {73--89},
}

@misc{cryptoeprint:2011:565,
	title = {Cryptographic hash functions: {Recent} design trends and security notions},
	author = {Al-Kuwari, Saif and Davenport, James H. and Bradford, Russell J.},
	year = {2011},
	note = {Cryptology ePrint Archive, Report 2011/565},
}

@inproceedings{nguyen-van_scalable_2019,
	title = {Scalable {Distributed} {Random} {Number} {Generation} {Based} on {Homomorphic} {Encryption}},
	doi = {10.1109/Blockchain.2019.00083},
	abstract = {Generating a secure source of publicly-verifiable randomness could be the single most fundamental technical challenge on a distributed network, especially in the blockchain context. Many current proposals face serious problems of scalability and security issues. We present a protocol which can be implemented on a blockchain that ensures unpredictable, tamper-resistant, scalable and publicly-verifiable outcomes. The main building blocks of our protocol are homomorphic encryption (HE) and verifiable random functions (VRF). The use of homomorphic encryption enables mathematical operations to be performed on encrypted data, to ensure no one knows the outcome prior to being generated. The protocol requires O(n) elliptic curve multiplications and additions as well as O(n) signature signing and verification operations, which permits great scalability. We present a comparison between recent approaches to the generation of random beacons.},
	booktitle = {2019 {IEEE} {International} {Conference} on {Blockchain} ({Blockchain})},
	author = {Nguyen-Van, Thanh and Nguyen-Anh, Tuan and Le, Tien-Dat and Nguyen-Ho, Minh-Phuoc and Nguyen-Van, Tuong and Le, Nhat-Quang and Nguyen-An, Khuong},
	month = jul,
	year = {2019},
	keywords = {Blockchain, Complexity theory, Elliptic curves, Encryption, Protocols, random beacons, homomorphic encryption, elliptic curve cryptography, verifiable random function, distributed ledgers, decentralized schemes, blockchain based applications},
	pages = {572--579},
}

@misc{rescorla_transport_2018,
	title = {The transport layer security ({TLS}) protocol version 1.3},
	url = {https://www.rfc-editor.org/info/rfc8446},
	abstract = {This document specifies version 1.3 of the Transport Layer Security (TLS) protocol. TLS allows client/server applications to communicate over the Internet in a way that is designed to prevent eavesdropping, tampering, and message forgery. This document updates RFCs 5705 and 6066, and obsoletes RFCs 5077, 5246, and 6961. This document also specifies new requirements for TLS 1.2 implementations.},
	publisher = {RFC Editor},
	author = {Rescorla, Eric},
	month = aug,
	year = {2018},
}

@misc{noauthor_solidity_nodate,
	title = {Solidity documentation},
	url = {https://docs.soliditylang.org},
	urldate = {2022-03-26},
}

@misc{noauthor_algorand_nodate,
	title = {Algorand ({ALGO}) {Blockchain} {Explorer}},
	url = {https://algoexplorer.io/},
	abstract = {AlgoExplorer allows you to explore and search the Algorand blockchain for transactions, 
						addresses, stake rewards, stats, tokens, price and other activities taking place on the Algorand network.},
	urldate = {2022-03-26},
}

@article{pierrot_malleability_2018,
	title = {Malleability of the blockchain’s entropy},
	volume = {10},
	issn = {1936-2455},
	url = {https://doi.org/10.1007/s12095-017-0264-3},
	doi = {10.1007/s12095-017-0264-3},
	abstract = {Trustworthy generation of public random numbers is necessary for the security of a number of cryptographic applications. It was suggested to use the inherent unpredictability of blockchains as a source of public randomness. Entropy from the Bitcoin blockchain in particular has been used in lotteries and has been suggested for a number of other applications ranging from smart contracts to election auditing. In this Arcticle, we analyse this idea and show how an adversary could manipulate these random numbers, even with limited computational power and financial budget.},
	language = {en},
	number = {1},
	urldate = {2022-03-24},
	journal = {Cryptography and Communications},
	author = {Pierrot, Cécile and Wesolowski, Benjamin},
	month = jan,
	year = {2018},
	pages = {211--233},
}

@misc{etherscanio_ethereum_nodate,
	title = {Ethereum {Gas} {Tracker} {\textbar} {Etherscan}},
	url = {http://etherscan.io/gastracker},
	abstract = {Gas Snapshot Price at 3/22/2022 1:08:37 PM UTC - Low: 23 gwei {\textbar} Avg: 23 gwei {\textbar} High: 24 gwei},
	language = {en},
	urldate = {2022-03-22},
	journal = {Ethereum (ETH) Blockchain Explorer},
	author = {{etherscan.io}},
}

@misc{buterin_ethereum_2014,
	title = {Ethereum: {A} {Next}-{Generation} {Smart} {Contract} and {Decentralized} {Application} {Platform}.},
	url = {https://ethereum.org/en/whitepaper/},
	urldate = {2022-03-26},
	collaborator = {Buterin, Vitalik},
	year = {2014},
}

@inproceedings{10.1109/SFCS.1983.48,
	address = {USA},
	series = {{SFCS} '83},
	title = {Randomized byzantine generals},
	isbn = {0-8186-0508-1},
	url = {https://doi.org/10.1109/SFCS.1983.48},
	doi = {10.1109/SFCS.1983.48},
	abstract = {We present a randomized solution for the Byzantine Generals Problems. The solution works in the synchronous as well as the asynchronous case and produces Byzantine Agreement within a fixed small expected number of computational rounds, independent of the number n of processes and the bound t on the number of faulty processes. The solution uses A. Shamir's method for sharing secrets. It specializes to produce a simple solution for the Distributed Commit problem.},
	booktitle = {Proceedings of the 24th annual symposium on foundations of computer science},
	publisher = {IEEE Computer Society},
	author = {Rabin, Michael O.},
	year = {1983},
	note = {Number of pages: 7},
	pages = {403--409},
}

@article{10.1145/322186.322188,
	title = {Reaching agreement in the presence of faults},
	volume = {27},
	issn = {0004-5411},
	url = {https://doi.org/10.1145/322186.322188},
	doi = {10.1145/322186.322188},
	abstract = {The problem addressed here concerns a set of isolated processors, some unknown subset of which may be faulty, that communicate only by means of two-party messages. Each nonfaulty processor has a private value of information that must be communicated to each other nonfaulty processor. Nonfaulty processors always communicate honestly, whereas faulty processors may lie. The problem is to devise an algorithm in which processors communicate their own values and relay values received from others that allows each nonfaulty processor to infer a value for each other processor. The value inferred for a nonfaulty processor must be that processor's private value, and the value inferred for a faulty one must be consistent with the corresponding value inferred by each other nonfaulty processor.It is shown that the problem is solvable for, and only for, n ≥ 3m + 1, where m is the number of faulty processors and n is the total number. It is also shown that if faulty processors can refuse to pass on information but cannot falsely relay information, the problem is solvable for arbitrary n ≥ m ≥ 0. This weaker assumption can be approximated in practice using cryptographic methods.},
	number = {2},
	journal = {Journal of The Acm},
	author = {Pease, M. and Shostak, R. and Lamport, L.},
	month = apr,
	year = {1980},
	note = {Number of pages: 7
Place: New York, NY, USA
Publisher: Association for Computing Machinery
tex.issue\_date: April 1980},
	pages = {228--234},
}

@misc{noauthor_bitcoin_nodate,
	title = {Bitcoin - {Open} source {P2P} money},
	url = {https://bitcoin.org/en/},
	abstract = {Bitcoin is an innovative payment network and a new kind of money. Find all you need to know and get started with Bitcoin on bitcoin.org.},
	language = {en},
	urldate = {2022-03-21},
}

@misc{noauthor_ethereum_nodate,
	title = {Ethereum},
	url = {https://ethereum.org},
	abstract = {Ethereum is a global, decentralized platform for money and new kinds of applications. On Ethereum, you can write code that controls money, and build applications accessible anywhere in the world.},
	language = {en},
	urldate = {2022-03-21},
	journal = {ethereum.org},
}

@incollection{RogawayPhillip2004CHBD,
	address = {Berlin, Heidelberg},
	series = {Lecture notes in computer science},
	title = {Cryptographic hash-function basics: {Definitions}, implications, and separations for preimage resistance, second-preimage resistance, and collision resistance},
	isbn = {3-540-22171-9},
	abstract = {We consider basic notions of security for cryptographic hash functions: collision resistance, preimage resistance, and second-preimage resistance. We give seven different definitions that correspond to these three underlying ideas, and then we work out all of the implications and separations among these seven definitions within the concrete-security, provable-security framework. Because our results are concrete, we can show two types of implications, conventional and provisional, where the strength of the latter depends on the amount of compression achieved by the hash function. We also distinguish two types of separations, conditional and unconditional. When constructing counterexamples for our separations, we are careful to preserve specified hash-function domains and ranges; this rules out some pathological counterexamples and makes the separations more meaningful in practice. Four of our definitions are standard while three appear to be new; some of our relations and separations have appeared, others have not. Here we give a modern treatment that acts to catalog, in one place and with carefully-considered nomenclature, the most basic security notions for cryptographic hash functions.},
	language = {english},
	booktitle = {Fast software encryption},
	publisher = {Springer Berlin Heidelberg},
	author = {Rogaway, Phillip and Shrimpton, Thomas},
	year = {2004},
	note = {ISSN: 0302-9743
tex.copyright: Springer-Verlag Berlin Heidelberg 2004},
	keywords = {Applied sciences, Cryptography, Exact sciences and technology, Information, Signal and communications theory, Telecommunications and information theory, collision resistance, cryptographic hash functions, preimage resistance, provable security, second-preimage resistance, signal and communications theory},
	pages = {371--388},
}

@misc{noauthor_sustainable_nodate,
	title = {Sustainable {Blockchain}: {Estimating} the {Carbon} {Footprint} of {Algorand}’s {Pure} {Proof}-of-{Stake}},
	shorttitle = {Sustainable {Blockchain}},
	url = {https://www.algorand.com/resources/blog/sustainable-blockchain-calculating-the-carbon-footprint/},
	abstract = {Pure Proof of Stake offers security, scalability, decentralization and… sustainability!},
	language = {en},
	urldate = {2022-03-18},
}

@misc{noauthor_cambridge_nodate,
	title = {Cambridge {Bitcoin} {Electricity} {Consumption} {Index} ({CBECI})},
	url = {https://ccaf.io/cbeci/index},
	abstract = {The Cambridge Bitcoin Electricity Consumption Index (CBECI) provides a real-time estimate of the total electricity consumption of the Bitcoin network. The CBECI is maintained by the Cambridge Centre for Alternative Finance (CCAF) at Judge Business School, University of Cambridge.},
	language = {en},
	urldate = {2022-03-18},
}

@article{fischer_impossibility_1985,
	title = {Impossibility of distributed consensus with one faulty process},
	volume = {32},
	issn = {0004-5411, 1557-735X},
	url = {https://dl.acm.org/doi/10.1145/3149.214121},
	doi = {10.1145/3149.214121},
	abstract = {The consensus problem involves an asynchronous system of processes, some of which may be unreliable. The problem is for the reliable processes to agree on a binary value. In this paper, it is shown that every protocol for this problem has the possibility of nontermination, even with only one faulty process. By way of contrast, solutions are known for the synchronous case, the “Byzantine Generals” problem.},
	language = {en},
	number = {2},
	urldate = {2022-03-17},
	journal = {Journal of the ACM},
	author = {Fischer, Michael J. and Lynch, Nancy A. and Paterson, Michael S.},
	month = apr,
	year = {1985},
	pages = {374--382},
}

@misc{computer_security_division_interoperable_2019,
	title = {Interoperable {Randomness} {Beacons} {\textbar} {CSRC} {\textbar} {CSRC}},
	url = {https://csrc.nist.gov/projects/interoperable-randomness-beacons},
	abstract = {The Interoperable Randomness Beacons project at NIST intends to promote the availability of trusted public randomness as a public utility. This can be used for example for auditability and transparency of services that depend on randomized processes.  The project is spearheaded by the Cryptographic Technology Group in the Computer Security Division of the Information Technology Laboratory (ITL), and has counted with the participation of many collaborators over the years.  WARNING: Do NOT use Beacon generated values as cryptographic secret keys!  The webpage of the NIST Randomness Beacon (with actual random values) is located at: https://beacon.nist.gov/home      Historical notes      Collaborators: Ron Rivest played an important early role in motivating the creation of the project, by pointing out to NIST that a public source of randomness could be valuable for auditing voting machines. Michael Fischer was a valuable early collaborator in thinking about a theoretical framework for public randomness. Andrew...},
	language = {EN-US},
	urldate = {2022-03-17},
	journal = {CSRC {\textbar} NIST},
	author = {Computer Security Division, Information Technology Laboratory},
	month = jun,
	year = {2019},
}

@article{wesolowski_efficient_2020,
	title = {Efficient {Verifiable} {Delay} {Functions}},
	volume = {33},
	issn = {1432-1378},
	url = {https://doi.org/10.1007/s00145-020-09364-x},
	doi = {10.1007/s00145-020-09364-x},
	abstract = {We construct a verifiable delay function (VDF). A VDF is a function whose evaluation requires running a given number of sequential steps, yet the result can be efficiently verified. They have applications in decentralised systems, such as the generation of trustworthy public randomness in a trustless environment, or resource-efficient blockchains. To construct our VDF, we actually build a trapdoor VDF. A trapdoor VDF is essentially a VDF which can be evaluated efficiently by parties who know a secret (the trapdoor). By setting up this scheme in a way that the trapdoor is unknown (not even by the party running the setup, so that there is no need for a trusted setup environment), we obtain a simple VDF. Our construction is based on groups of unknown order such as an RSA group or the class group of an imaginary quadratic field. The output of our construction is very short (the result and the proof of correctness are each a single element of the group), and the verification of correctness is very efficient.},
	language = {en},
	number = {4},
	urldate = {2022-03-15},
	journal = {Journal of Cryptology},
	author = {Wesolowski, Benjamin},
	month = oct,
	year = {2020},
	pages = {2113--2147},
}

@techreport{10.5555/888615,
	address = {USA},
	title = {Time-lock puzzles and timed-release crypto},
	abstract = {Our motivation is the notion of “timed-release crypto,”” where the goal is to encrypt a message so that it can not be decrypted by anyone, not even the sender, until a pre-determined amount of time has passed. The goal is to “send information into the future.”” This problem was first discussed by Timothy May citeMay93. What are the applications of “timed-release crypto””? Here are a few possibilities (some due to May): A bidder in an auction wants to seal his bid so that it can only be opened after the bidding period is closed. A homeowner wants to give his mortgage holder a series of encrypted mortgage payments. These might be encrypted digital cash with different decryption dates, so that one payment becomes decryptable (and thus usable by the bank) at the beginning of each successive month. An individual wants to encrypt his diaries so that they are only decryptable after fifty years. A key-escrow scheme can be based on timed-release crypto, so that the government can get the message keys, but only after a fixed period (say one year). There are presumably many other applications. There are two natural approaches to implementing timed-release crypto: Use “time-lock puzzles””–computational problems that can not be solved without running a computer continuously for at least a certain amount of time. Use trusted agents who promise not to reveal certain information until a specified date. Using trusted agents has the obvious problem of ensuring that the agents are trustworthy; secret-sharing approaches can be used to alleviate this concern. Using time-lock puzzles has the problem that the CPU time required to solve a problem can depend on the amount and nature of the hardware used to solve the problem, as well as the parallelizability of the computational problem being solved. In this note we explore both approaches. (We note that Tim May has suggested an approach based on the use of trusted agents.)},
	institution = {Massachusetts Institute of Technology},
	author = {Rivest, R. L. and Shamir, A. and Wagner, D. A.},
	year = {1996},
}

@techreport{rivest_time-lock_1996,
	address = {USA},
	type = {Technical {Report}},
	title = {Time-lock {Puzzles} and {Timed}-release {Crypto}},
	abstract = {Our motivation is the notion of ``timed-release crypto,'''' where the goal is to encrypt a message so that it can not be decrypted by anyone, not even the sender, until a pre-determined amount of time has passed. The goal is to ``send information into the future.'''' This problem was first discussed by Timothy May {\textbackslash}cite\{May93\}. What are the applications of ``timed-release crypto''''? Here are a few possibilities (some due to May): A bidder in an auction wants to seal his bid so that it can only be opened after the bidding period is closed. A homeowner wants to give his mortgage holder a series of encrypted mortgage payments. These might be encrypted digital cash with different decryption dates, so that one payment becomes decryptable (and thus usable by the bank) at the beginning of each successive month. An individual wants to encrypt his diaries so that they are only decryptable after fifty years. A key-escrow scheme can be based on timed-release crypto, so that the government can get the message keys, but only after a fixed period (say one year). {\textbackslash} There are presumably many other applications. There are two natural approaches to implementing timed-release crypto: Use ``time-lock puzzles''''--computational problems that can not be solved without running a computer continuously for at least a certain amount of time. Use trusted agents who promise not to reveal certain information until a specified date. Using trusted agents has the obvious problem of ensuring that the agents are trustworthy; secret-sharing approaches can be used to alleviate this concern. Using time-lock puzzles has the problem that the CPU time required to solve a problem can depend on the amount and nature of the hardware used to solve the problem, as well as the parallelizability of the computational problem being solved. In this note we explore both approaches. (We note that Tim May has suggested an approach based on the use of trusted agents.)},
	institution = {Massachusetts Institute of Technology},
	author = {Rivest, R. L. and Shamir, A. and Wagner, D. A.},
	year = {1996},
}

@book{bertino_computer_2021,
	address = {Cham, Switzerland},
	series = {Lecture notes in computer science},
	title = {Computer security – {ESORICS} 2021: 26th {European} {Symposium} on {Research} in {Computer} {Security}, {Darmstadt}, {Germany}, {October} 4–8, 2021: proceedings. {Part} 2},
	isbn = {9783030884277},
	shorttitle = {Computer security – {ESORICS} 2021},
	language = {eng},
	number = {12973},
	publisher = {Springer},
	editor = {Bertino, Elisa and Shulman, Haya and Waidner, Michael},
	year = {2021},
}

@inproceedings{10.1145/12130.12168,
	address = {New York, NY, USA},
	series = {{STOC} '86},
	title = {Limits on the security of coin flips when half the processors are faulty},
	isbn = {0-89791-193-8},
	url = {https://doi-org.libproxy.helsinki.fi/10.1145/12130.12168},
	doi = {10.1145/12130.12168},
	booktitle = {Proceedings of the eighteenth annual {ACM} symposium on theory of computing},
	publisher = {Association for Computing Machinery},
	author = {Cleve, R},
	year = {1986},
	note = {Number of pages: 6
Place: Berkeley, California, USA},
	pages = {364--369},
}

@inproceedings{micali_verifiable_1999,
	title = {Verifiable random functions},
	doi = {10.1109/SFFCS.1999.814584},
	booktitle = {40th {Annual} {Symposium} on {Foundations} of {Computer} {Science} ({Cat}. {No}.{99CB37039})},
	author = {Micali, S. and Rabin, M. and Vadhan, S.},
	year = {1999},
	pages = {120--130},
}

@article{goldreich_how_1986,
	title = {How to {Construct} {Random} {Functions}},
	volume = {33},
	issn = {0004-5411},
	url = {https://doi.org/10.1145/6490.6503},
	doi = {10.1145/6490.6503},
	abstract = {A constructive theory of randomness for functions, based on computational complexity, is developed, and a pseudorandom function generator is presented. This generator is a deterministic polynomial-time algorithm that transforms pairs (g, r), where g is any one-way function and r is a random k-bit string, to polynomial-time computable functions undefinedr: 1, … , 2k → 1, … , 2k. These undefinedr's cannot be distinguished from random functions by any probabilistic polynomial-time algorithm that asks and receives the value of a function at arguments of its choice. The result has applications in cryptography, random constructions, and complexity theory.},
	number = {4},
	journal = {J. ACM},
	author = {Goldreich, Oded and Goldwasser, Shafi and Micali, Silvio},
	month = aug,
	year = {1986},
	note = {Place: New York, NY, USA
Publisher: Association for Computing Machinery},
	pages = {792--807},
}

@article{shamir_how_1979,
	title = {How to {Share} a {Secret}},
	volume = {22},
	issn = {0001-0782},
	url = {https://doi.org/10.1145/359168.359176},
	doi = {10.1145/359168.359176},
	abstract = {In this paper we show how to divide data D into n pieces in such a way that D is easily reconstructable from any k pieces, but even complete knowledge of k - 1 pieces reveals absolutely no information about D. This technique enables the construction of robust key management schemes for cryptographic systems that can function securely and reliably even when misfortunes destroy half the pieces and security breaches expose all but one of the remaining pieces.},
	number = {11},
	journal = {Commun. ACM},
	author = {Shamir, Adi},
	month = nov,
	year = {1979},
	note = {Place: New York, NY, USA
Publisher: Association for Computing Machinery},
	keywords = {cryptography, interpolation, key management},
	pages = {612--613},
}

@article{goldwasser_knowledge_1989,
	title = {The {Knowledge} {Complexity} of {Interactive} {Proof} {Systems}},
	volume = {18},
	url = {https://www.proquest.com/scholarly-journals/knowledge-complexity-interactive-proof-systems/docview/919784312/se-2},
	abstract = {Usually, a proof of a theorem contains more knowledge than the mere fact that the theorem is true. For instance, to prove that a graph is Hamiltonian it suffices to exhibit a Hamiltonian tour in it; however, this seems to contain more knowledge than the single bit Hamiltonian/non-Hamiltonian. In this paper a computational complexity theory of the "knowledge" contained in a proof is developed. Zero-knowledge proofs are defined as those proofs that convey no additional knowledge other than the correctness of the proposition in question. Examples of zero-knowledge proof systems are given for the languages of quadratic residuosity and 'quadratic nonresiduosity. These are the first examples of zero-knowledge proofs for languages not known to be efficiently recognizable.},
	language = {English},
	number = {1},
	journal = {SIAM Journal on Computing},
	author = {Goldwasser, Shafi and Micali, Silvio and Rackoff, Charles},
	month = feb,
	year = {1989},
	note = {ISBN: 00975397},
	keywords = {Algorithms, Coins, Computer science, Knowledge, Language, Mathematics, Probability distribution},
	pages = {186--23},
}

@article{dharanikota_breeding_2020,
	title = {Breeding unicorns: {Developing} trustworthy and scalable randomness beacons},
	volume = {15},
	issn = {1932-6203},
	shorttitle = {Breeding unicorns},
	url = {https://dx.plos.org/10.1371/journal.pone.0232261},
	doi = {10.1371/journal.pone.0232261},
	language = {en},
	number = {4},
	urldate = {2022-03-14},
	journal = {PLOS ONE},
	author = {Dharanikota, Samvid and Jensen, Michael Toft and Kristensen, Sebastian Rom and Michno, Mathias Sass and Pignolet, Yvonne-Anne and Rydhof Hansen, René and Schmid, Stefan},
	editor = {Debiao, He},
	month = apr,
	year = {2020},
	pages = {e0232261},
}

@article{cachin_random_2005,
	title = {Random {Oracles} in {Constantinople}: {Practical} {Asynchronous} {Byzantine} {Agreement} {Using} {Cryptography}},
	volume = {18},
	issn = {0933-2790, 1432-1378},
	shorttitle = {Random {Oracles} in {Constantinople}},
	url = {http://link.springer.com/10.1007/s00145-005-0318-0},
	doi = {10.1007/s00145-005-0318-0},
	language = {en},
	number = {3},
	urldate = {2022-03-14},
	journal = {Journal of Cryptology},
	author = {Cachin, Christian and Kursawe, Klaus and Shoup, Victor},
	month = jul,
	year = {2005},
	pages = {219--246},
}

@article{rabin_transaction_1983,
	title = {Transaction protection by beacons},
	volume = {27},
	issn = {0022-0000},
	url = {https://www.sciencedirect.com/science/article/pii/0022000083900429},
	doi = {10.1016/0022-0000(83)90042-9},
	abstract = {Protocols for implementing contract signing, confidential disclosures, and certified mail in an electronic mail system are proposed. These transactions are provably impossible without a trusted intermediary. However, they can be implemented with just a small probability of a participant cheating his partner, by use of a beacon emitting random integers. Applications include privacy protection of personal information in data banks, as well as the protection of business transactions.},
	language = {en},
	number = {2},
	urldate = {2022-03-14},
	journal = {Journal of Computer and System Sciences},
	author = {Rabin, Michael O.},
	month = oct,
	year = {1983},
	pages = {256--267},
}

@techreport{lenstra_random_2015,
	title = {A random zoo: sloth, unicorn, and trx},
	shorttitle = {A random zoo},
	url = {https://eprint.iacr.org/2015/366},
	abstract = {Many applications require trustworthy generation of public random numbers. It is shown how this can be achieved using a hash function that is timed to be as slow as desired (sloth), while the correctness of the resulting hash can be verified quickly. It is shown how sloth can be used for uncontestable random number generation (unicorn), and how unicorn can be used for a new trustworthy random elliptic curves service (trx) and random-sample voting.},
	number = {366},
	urldate = {2022-03-14},
	author = {Lenstra, Arjen K. and Wesolowski, Benjamin},
	year = {2015},
	keywords = {random-sample voting, slow-times hash, trustworthy random elliptic curves service, uncontestable random numbers},
}

@misc{corrigan-gibbs_ensuring_2014,
	title = {Ensuring {High}-{Quality} {Randomness} in {Cryptographic} {Key} {Generation}},
	author = {Corrigan-Gibbs, Henry and Mu, Wendy and Boneh, Dan and Ford, Bryan},
	year = {2014},
	note = {\_eprint: 1309.7366},
}

@misc{noauthor_hard_nodate,
	title = {Hard {Problems} of {Cryptocurrency} 2015},
	url = {https://eth.wiki/en/ideas/hpoc_2015},
	language = {en},
	urldate = {2022-02-08},
	journal = {Ethereum Wiki},
}

@inproceedings{boneh_verifiable_2018,
	series = {Lecture {Notes} in {Computer} {Science} (including subseries {Lecture} {Notes} in {Artificial} {Intelligence} and {Lecture} {Notes} in {Bioinformatics})},
	title = {Verifiable delay functions},
	isbn = {978-3-319-96883-4},
	doi = {10.1007/978-3-319-96884-1_25},
	abstract = {We study the problem of building a verifiable delay function (VDF). A VDF requires a specified number of sequential steps to evaluate, yet produces a unique output that can be efficiently and publicly verified. VDF s have many applications in decentralized systems, including public randomness beacons, leader election in consensus protocols, and proofs of replication. We formalize the requirements for VDF s and present new candidate constructions that are the first to achieve an exponential gap between evaluation and verification time.},
	language = {English (US)},
	booktitle = {Advances in {Cryptology} – {CRYPTO} 2018 - 38th {Annual} {International} {Cryptology} {Conference}, 2018, {Proceedings}},
	publisher = {Springer Verlag},
	author = {Boneh, Dan and Bonneau, Joseph and Bünz, Benedikt and Fisch, Ben},
	editor = {Boldyreva, Alexandra and Shacham, Hovav},
	year = {2018},
	pages = {757--788},
}

@inproceedings{syta_scalable_2017,
	title = {Scalable {Bias}-{Resistant} {Distributed} {Randomness}},
	doi = {10.1109/SP.2017.45},
	booktitle = {2017 {IEEE} {Symposium} on {Security} and {Privacy} ({SP})},
	author = {Syta, Ewa and Jovanovic, Philipp and Kogias, Eleftherios Kokoris and Gailly, Nicolas and Gasser, Linus and Khoffi, Ismail and Fischer, Michael J. and Ford, Bryan},
	year = {2017},
	pages = {444--460},
}

@misc{noauthor_verifiable_2020,
	title = {Verifiable {Randomness} for {Blockchain} {Smart} {Contracts}},
	url = {https://blog.chain.link/chainlink-vrf-on-chain-verifiable-randomness/},
	abstract = {Chainlink VRF (Verifiable Randomness Function) allows blockchain developers to easily add verifiable randomness to their smart contracts.},
	language = {en-US},
	urldate = {2022-02-09},
	journal = {Chainlink Blog},
	month = may,
	year = {2020},
}

@inproceedings{simic_review_2020,
	title = {A {Review} on {Generating} {Random} {Numbers} in {Decentralised} {Environments}},
	doi = {10.23919/MIPRO48935.2020.9245302},
	booktitle = {2020 43rd {International} {Convention} on {Information}, {Communication} and {Electronic} {Technology} ({MIPRO})},
	author = {Simić, Srđan Daniel and Šajina, Robert and Tanković, Nikola and Etinger, Darko},
	year = {2020},
	pages = {1668--1673},
}

@article{lesaege_kleros_2020,
	title = {Kleros: {Research} {Challenges} in {Decentralized} {Justice}},
	author = {Lesaege, Clément and George, William and Ast, Federico},
	month = mar,
	year = {2020},
}

@misc{pooltogether_pooltogether_nodate,
	title = {{PoolTogether}},
	url = {https://pooltogether.com},
	abstract = {Win by saving with PoolTogether. The more you save, the more you win!},
	urldate = {2022-02-08},
	journal = {PoolTogether},
	author = {{PoolTogether}},
}

@book{christianson_security_2011,
	address = {Berlin Heidelberg},
	series = {Lecture notes in computer science},
	title = {Security protocols {XVI}: 16th international workshop, {Cambridge}, {UK}, {April} 16-18, 2008 ; revised selected papers},
	isbn = {9783642221378 9783642221361},
	shorttitle = {Security protocols {XVI}},
	language = {eng},
	number = {6615},
	publisher = {Springer},
	editor = {Christianson, Bruce},
	year = {2011},
}
