\chapter{Satunnaisuuden tuottaminen\label{results}}

\section{Ulkoiset menetelmät}

Lohkoketjusovelluksen ei tarvitse itse tuottaa satunnaisuuttaan. Esitetään kaksi yleistä tapaa, jolla älysopimukset voivat saada käyttöönsä satunnaisuutta.

Yksinkertaisin lohkoketjusovelluksien käyttämä satunnaisuuden lähde on sovitun lohkon tiiviste. Esimerkiksi lottoarvonta voitaisiin suorittaa niin, että älysopimukseen on määritelty, että voitto jaetaan lohkonumeroltaan tietyn tulevan lohkon tiivisteen perusteella. Tiivistettä käytetään niin PoW- kuin PoS-ketjuissa, vaikkakin PoS-ketjussa tiiviste on helposti validaattorin manipuloitavissa. PoW-ketjun lohkon tiiviste täyttää vaatimukset 1-3, mutta kaivajat voivat vaikuttaa arvoon, joten luku on manipuloitavissa eikä täytä vaatimusta 4. Jos kaivajan saama hyöty epäedullisen tiivisteen omaavan lohkon julkaisematta jättämisestä on suurempi kuin lohkon julkaisemisesta saatava palkinto, niin kaivajalla on intressi jättää lohko julkaisematta. Tämä aiheuttaa vinouman satunnaislukujen jakaumaan kaivajalle edulliseen suuntaan. Esimerkiksi Bitcoin-ketjun tapauksessa hyökkääjä ei tarvitse yhden lohkon tiivisteen jakauman merkittävään manipuloimiseen enemmistöä tai edes merkittävää taloudellista panostusta suhteessa ketjun kokoon \cite{pierrot_malleability_2018}.

Toinen suosittu ulkoinen lähde on Chainlink VRF \cite{noauthor_chainlink_nodate}, joka käyttää satunnaisuuden tuottamiseen \textit{Todennettavaa Satunnaisfunktiota (Verifiable Random Function, VRF)}. Käytetään VRF:n määrittelyyn tutkielmalle riittävällä abstraktiotasolla Papadopoulos et al. esittämää kuvausta \cite{papadopoulos2017making}. "VRF on pohjimmiltaan julkisen avaimen versio avainta käyttävästä kryptografisesta tiivisteestä." \cite{papadopoulos2017making} Vain salaisen avaimen omistaja voi laskea tiivisteen $h$ syötteellä $x$, mutta kuka tahansa vastaavan julkisen avaimen omaava voi todentaa, että tiiviste on laskettu käyttäen salaista avainta. 

\begin{equation}
    h = H_{SK}(x)
\end{equation}

Salaista avainta käyttäen tuotetaan myös todiste, jolla oikeellisuus voidaan todentaa kuitenkaan paljastamatta itse avainta.

Chainlink VRF:ää hyödyntävä sovellus käyttää Chainlink verkon satunnaislukuoraakkelia, joka tarjoaa sovellukselle vaatimukset 1-4 täyttävän satunnaisluvun käyttäen todennettavaa satunnaisfunktiota. Älysopimuksen pitää pyytää satunnaislukua, minkä jälkeen Chainlink verkon serveri lähettää älysopimukseen satunnaisen arvon sisältävän transaktion. Tämän satunnaisluvun saaminen kuitenkin maksaa Chainlink virtuaalivaluuttaa, ja sovellukselle ulkopuolisesta palvelusta maksaminen ei ole välttämättä käytännöllistä. Jos Chainlink VRF:n käyttöä ei toteuteta oikein älysopimuksessa, niin esimerkiksi kaivajilla voi olla mahdollisuus vaikuttaa arvoon \cite{noauthor_chainlink_nodate}.

Lohkoketjusovellus voi vaatia käytettävän menetelmää, jossa satunnaisluvun tuottaminen onnistuu itse sovelluksen käyttäjiltä. Seuraavaksi esitetään protokollia, joissa sovelluksen käyttäjät vastaavat satunnaisuuden tuottamisesta. Aloitetaan yksinkertaisella protokollalla, joka ei täytä vaatimuksia, mutta jonka pohjalle moni protokolla rakentuu.

\section{Kommitointi ja paljastaminen} %Miksi täyttää vaatimukset?
Kommitoinnin ja paljastamisen protokollassa satunnaisluku tuotetaan kahdessa osassa. Ensimmäisellä kierroksella jokainen osallistuja kommitoi ensin kaikkien nähtäväksi lohkoketjuun satunnaisluvun tiivisteen. Toisella kierroksella osallistujat paljastavat yksi kerrallaan kommitoidunsa satunnaisluvun, jonka tiiviste vastaa ensin kommitoitua tiivistettä. Paljastetuista luvuista lasketaan XOR, minkä seurauksena saadaan satunnaisluku. Olettaen, että vähintään yksi osallistuja on rehellinen, tämä protokolla täyttää vaatimukset 2 ja 3. Ongelmana protokollassa on, että viimeinen paljastaja näkee tuotettavan satunnaisluvun ja voi täten olla julkaisematta syötettään jos tuotettu luku ei ole suosiollinen. Tällöin hyökkääjä voi estää satunnaisuuden tuottamisen ja pakottaa protokollan aloittamaan alusta manipuloiden satunnaisuuden jakaumaa. Vaatimuksilla 1 ja 4 on siis yhteys, sillä pakottamalla protokollan aloittamisen alusta voi manipuloida protokollan tuottamia lukuja.

\section{Todennettavan Viivefunktion hyödyntäminen}
\textit{Todennettava Viivefunktio  (Verifiable Delay Function, VDF)} on funktio, jonka evaluointi vaatii määritellyn määrän peräkkäisiä laskutoimituksia, mutta on tehokkaasti julkisesti vahvistettavissa, että tietty syöte tuottaa tietyn tuloksen \cite{boneh_verifiable_2018}. VDF:n evaluointi ei nopeudu rinnaikkaistamalla evaluointia, ja se mahdollistaa teoreettisen alarajan asettamisen sille, kuinka kauan evaluoinnissa kuluu aikaa. Lohkon tiivistettä sekä osallistujien kommitointia käyttävien protokollien heikkouksia voidaan parantaa käyttämällä VDF:ää \cite{boneh_verifiable_2018}. 

Tiivisteen käyttämisen tapauksessa älysopimuksessa määritetään, että satunnaisuuden lähteenä käytetään tietyn tulevaisuuden lohkon tiivistettä. Tiivistettä ei käytetä suoraan, vaan satunnainen arvo saadaan syöttämällä tiiviste VDF:lle. VDF:n evaluointi suoritetaan off-chain laskentana ja tulos julkaistaan lohkoketjuun. Kun VDF:n aiheuttama viive valitaan sopivasti, ei lohkon kaivaja ehdi simuloimaan satunnaista arvoa ja tekemään päätöstä lohkon julkaisemisesta ennen kuin rehelliset kaivajat ovat lisänneet uuden tai jopa monia uusia lohkoja lohkoketjuun.

Käytettäessä tiivistettä VDF:n kanssa on kommunikointikustannus vakio. Satunnaisluvun saamiseksi sopimuksen kanssa pitää vuorovaikuttaa vain kaksi kertaa. Kerran tulevan lohkon numeron päättämiseksi ja toisen kerran VDF:stä saadun tuloksen julkaisemiseksi ketjuun. Satunnaisluku on satunnainen riippumatta osallistujista ja luvun tuottaminen on julkisesti vahvistettavissa VDF:n ominaisuuksien mukaisesti. Tiiviste VDF:n kanssa on myös Sybil resistentti, sillä satunnainen luku ei riipu osallistujien syötteestä ja sen julkaisemiseksi tarvitaan vain yksi rehellinen osallistuja.

Parannellussa kommitoinnin protokollassa kaikki osallistujat syöttävät sopimukseen heti satunnaisen arvonsa. Arvojen XOR tai tiiviste syötetään VDF:lle. Kuka tahansa osallistujista voi julkaista VDF:n tuottaman satunnaisen arvon. Myös tässä tapauksessa VDF:n viive aiheuttaa sen, että hyökkääjä ei voi simuloida satunnaista arvoa ennen kuin on myöhäistä. 

Protokollan kommunikointikustannus on myös vakio. Protokolla vaatii osallistujilta yhden transaktion satunnaisuuden kommitointia varten ja yhdeltä osallistujalta transaktion VDF:n tuottaman arvon julkaisemiseksi. Arvo on satunnainen eikä sen tuottamista voi estää kunhan vähintään yksi osallistuja on rehellinen, minkä johdosta protokolla on myös Sybil resistentti.

VDF:n käytännön toteutusta vaikeuttaa käyttäjien laitteistoerot. VDF:n viive pitää valita oikein, jotta tehokaskaan hyökkääjä ei saa evaluoitua funktiota liian nopeasti, mutta samalla pienemmän laskentatehon omaavien käyttäjien pitäisi pystyä evaluoimaan funktio käytännöllisessä ajassa. Tämän ongelman takia VDF:n pitää myös olla sellainen, että sen evaluointiin ei saa merkittävää etua laitteistotason optimoinnilla.

\section{Julkisen todennettavan salaisuuksien jakamisen hyödyntäminen}

\textit{Salaisuuksien jakaminen Secret Sharing, SS)} on tekniikka, jolla salaisuuden s jakaja voi jakaa n osallistujalle salaisuuden niin, että mikä tahansa t osallistujan joukko voi rekonstruktuoida salaisuuden kun toisaalta mikä tahansa joukko kooltaan pienempi kuin t ei saa minkäänlaista tietoa salaisuudesta \cite{shamir_how_1979}. \textit{Julkisesti todennettavassa salaisuuden jakamisessa (PVSS)} on julkisesti todennettavissa, että jakaja on jakanut validit salaisuuden osat \cite{StadlerMarkus2001PVSS}. Todentamisen voi suorittaa myös ulkopuoliset, joille ei ole jaettu salaisuuksien osia. Todennettavassa salaisuuden jakamisessa (VSS) osien todentamisen voi suorittaa vain salaisuuden osan vastaanottaja.

Yksi tapa estää kommitoinnin ja paljastamisen protokollan viimeisen paljastajan manipulointi on käyttää VSS:ää, mikä poistaa hyökkääjältä mahdollisuuden olla julkaisematta syötettään. Esimerkkinä VSS käytöstä kuvataan tiivistetysti RandShare-protokolla \cite{syta_scalable_2017}. Protokollassa tehdään oletus, että $N = 3t+1$ osallistujasta enintään $t$ osallistujaa on epärehellisiä. Jokainen osallistuja jakaa ensin oman salaisen syötteensä $N$ osaan VSS metodia käyttäen ja lähettää jokaiselle osallistujalle yhden osan. Protokollassa on määritelty, että salaisuuden rekonstruktuointi vaatii $t+1$ osaa. Kun kaikilla osallistujilla on muiden osallistujien osat ja ne on vahvistettu, ilmoitetaan valideista osista muille osallistujille. Validien salaisuuksien osat julkaistaan kaikille osallistujille vasta kun on tiedossa, että valideja salaisuuksia on vähintään $t+1$. Osallistuja voi rekonstruktuoida toisen osallistujan salaisuuden jos hän on vastaanottanut vähintään t osaa muilta osallistujilta. Siis epärehellinen osallistuja ei voi estää salaisuutensa julkaisemista, sillä oletuksen mukaan rehellisiä osallistujia on $2t+1$, mikä riittää siihen, että rehellisten osallistujien julkaistessa osansa, on rehellisillä osallistujilla vähintään $t+1$ osaa jokaisesta salaisuudesta ja kaikki salaisuudet julkaistaan.

Tämä protokolla täyttää kriteerit 1-4 kun hyökkääjiä on enintään $t$, mutta esimerkiksi kommunikaatiokompleksisuus on $O(n^3)$ \cite{syta_scalable_2017}. Tällä tarkoitetaan kuitenkin kaikkien osallistujien kommunikaatiokompleksisuutta. Yksittäisen osallistujan kommunikaatiokompleksisuus on $O(n^2)$. Lohkoketjusovelluksen tapauksessa protokollan on hyvä käyttää PVSS metodia, jotta kuka tahansa voi varmentaa protokollan oikeellisuuden. RandShare toimiikin vain yksinkertaisena esimerkkinä VSS:n käytöstä. 

PVSS pohjautuvia protokollia satunnaisuuden tuottamiseen on tutkittu laajasti viime vuosina \cite{bhat2022optrand, bhat2021randpiper, schindler_hydrand_2020, syta_scalable_2017} . Usein protokollia ei ole tarkoitettu toteutetuksi lohkoketjusovelluksessa, vaan tutkimusta motivoi konsensusmekanismien johtajan valinnan tai julkisen satunnaisuuden majakan kehittäminen. Viimeisin protokolla OptRand saavuttaa $O(N^2)$ pahimman tapauksen kokonaiskommunikointikompleksisuuden sietäen enintään $N/2$ hyökkääjää \cite{bhat2022optrand}. Yksittäisen käyttäjän kommunikointikompleksisuus on $O(N)$

Vaikka kommunikointikompleksisuutta onkin saatu madallettua, ei $O(N)$ kompleksisuus ole vielä riittävän pieni, että PVSS-protokollaa voitaisiin käyttää lohkoketjusovelluksessa, jossa satunnaisuuden tuottamiseen osallistuu tuhansia osallistujia, sillä yksittäisen käyttäjän transaktiokulut kasvavat liian suuriksi. Salaisien osien lisäksi yksittäisen käyttäjän pitää julkaista lohkoketjuun osien todisteita, jotta julkinen varmentaminen on mahdollista. Tämä lisää kommunikaatiokompleksisuuteen vakion, jolla on vaikutusta käytännön toteutuksen kannalta. Osien jakaminen vaatii tallennustilaa lohkoketjusta, mikä on erityisen kallista käyttäjälle. Lisäksi, jos PVSS-protokollana toteutettuun lohkoketjusovellukseen osallistuminen on ilmaista, niin protokolla on altis Sybil hyökkäykselle. Yksi hyökkääjä voi tällöin esiintyä helposti yli $t$ eri käyttäjänä.

\section{Merlin-ketju }

Merlin-ketju (Merlin chain) on sekvenssi $V_1, V_2 ... , V_n$, missä arvo $V_x$ on arvon $V_{x+1}$ tiiviste, jota voidaan käyttää lohkon tiivisteen kanssa vaatimukset 1-4 täyttävän protokollan rakentamiseen \cite{MerlinChains}. Protokolla estää kaivajien sekä osallistujien yritykset vaikuttaa tuotettavaan satunnaislukuun ja se pyrkii toimimaan jatkuvana satunnaislukujen lähteenä, majakkana. Kuvataan protokolla tiivistetysti.

Ennen osallistumista jokainen osallistuja tuottaa yksityisen satunnaisen arvon $V_n$, tallentaa tämän ja generoi arvosta Merlin-ketjun. $n$ valitaan niin, että Merlin-ketjussa on niin monta arvoa kuin osallistuja ikinä tarvitsee protokollan suorittamiseen tulevaisuudessa. Osallistuja paljastaa ketjun arvoja alkaen arvosta $V_1$. Paljastettuaan arvon $V_x$ osallistujan on pakko paljastaa seuraavaksi arvo $V_{x+1}$ tai löytää törmäys tiivisteelle $V_x$, minkä oletetaan olevan laskennallisesti mahdotonta. Merlin-ketju pakottaa osallistujan käyttämään ketjun ennalta määräämiä, mutta muille osallistujille satunnaisia, arvoja. Täten osallistuja ei voi reagoida muiden osallistujien arvoihin vaihtamalla omaa arvoaan.  

Olkoon seuraavana tuotettava satunnainen arvo $R_x$. Edellinen arvo on $R_{x-1}$ ja edellisen arvon lohko $B(R_{x-1})$.
Yksinkertaisessa mallissa on yksi osallistuja, tuottaja, joka syöttää älysopimukselle Merlin-ketjun arvoja yhdessä aikaleiman kanssa. Arvo hyväksytään sen täyttäessä tietyt ehdot. Arvon on oltava validi Merlin ketjun arvo, eli $H(V_x) = V_{x-1}$. Nykyisen lohkon lohkonumeron on oltava niin paljon suurempi kuin lohkon, jossa tuotettiin edellinen satunnaisluku, että voidaan olla varmoja edellisen lohkon muuttumattomuudesta. Sopimus tuottaa satunnaisen arvon laskemalla tiivisteen osallistujan arvosta, sekä edellisen satunnaisluvun lohkon seuraajan tiivisteestä, $R_x = H(\, V_x || H(B(R_{x-1})+1) \,)$. Satunnaisen arvon yhteydessä sopimus tuottaa myös aikaleiman, joka on aika, jolloin tuottaja pystyi ensimmäisen kerran simuloimaan tuotettavan arvon. 

Protokolla estää kaivajia manipuloimasta satunnaista arvoa, sillä kaivajilla ei ole tiedossa arvo $V_x$ lohkon kaivamisen hetkellä, eikä arvoa siten voi simuloida. Protokolla estää tuottajan tekemät manipuloimisyritykset käyttämällä Merlin-ketjua ja täten pakottamalla tuottajan syöttämään ennaltamäärättyjä arvoja. Vaatimukset 1-4 täyttyvät, kunhan tuottaja ei paljasta Merlin-ketjua etukäteen kaivajille. 

Yhdistämällä monen tuottajan arvot ehkäistään tuottajien ja kaivajien yhdessä tapahtuvan manipuloinnin uhka. Tällöin $R_x$ koostuu $N$ tuottajan satunnaisesta arvosta. Tuottajat suorittavat yhden tuottajan protokollan kerran ja jäävät odottamaan kunnes kaikki tuottajat ovat tuottaneet satunnaisen arvon. Tuottajien satunnaisista arvoista otetaan XOR, mikä muodostaa protokollan lopullisen satunnaisen arvon.

Protokolla täyttää vaatimukset, kunhan vähintään yksi tuottaja toimii rehellisesti ja kaikki tuottajat paljastavat arvonsa. Ongelmana on se mitä tehdään tuottajille, jotka eivät paljasta Merlin-ketjun arvojaan. Paljastamatta jättäminen lukitsee koko protokollan suorituksen ja ongelma on ratkaistava, jotta protokolla täyttää vaatimuksen 1. Protokollan kehittäjät ehdottavat, että arvonsa salaavat tuottajat voi poistaa tuottajien joukosta ja tuottajan Merlin-ketjun voisi palauttaa ratkaisemalla vähintään tietyn ajan vaativan ongelman (Timelock-puzzle) \cite{MerlinChains}.

Jos tuottaja vain poistetaan ja sivuutetaan, ilman tämän ketjun palauttamista, kohtaa protokolla ongelman, sillä lohkoketjuympäristössä hyökkääjä voi luoda uusia tilejä uusilla Merlin-ketjuilla, joilla osallistua tuottajina. Hyökkääjä lopettaa arvojen julkaisemisen aina kohdatessaan epäsuotuisen arvon ja pystyy täten vääristämään lopullisen satunnaisen arvon jakaumaa. 

Toisin sanoen, osallistumisen ollessa ilmaista, protokolla on altis Sybil hyökkäykselle, jossa hyökkääjä voi manipuloida satunnaista arvoa, mutta ei kuitenkaan päättää arvoa kun protokollaa suorittaa vähintään yksi rehellinen osallistuja.

Sybil resistenssiä voisi parantaa vaatimalla osallistujilta vakuus osallistuakseen. Jos tuottaja ei paljasta arvoaan tietyssä ajassa, menettää hän vakuutensa. Uusien tuottajien luominen olisi tällöin taloudellisesti kallista. Tuottajien historiaa voidaan myös seurata ja luoda avoin tilastointi tuottajan maineelle. Maineikkaita tuottajia palkittaisiin protokollan mukaisesta toiminnasta. Mitä muuttumattomampi ja maineikkaampi tuottajien joukko on, sitä turvallisemmin protokolla toimii. Tuottajien muuttumaton joukko ei kuitenkaan sovellu lohkoketjusovelluksiin, joissa käyttäjien joukko muuttuu jatkuvasti. 

Merlin-protokollan yksittäisen osallistujan kommunikointikustannus on vakio. Käyttäjän pitää lähettää yhden satunnaisluvun tuottamiseksi vain yksi transaktio, jossa tämä paljastaa Merlin-ketjun arvonsa. 

Caucus on toinen Merlin-ketjuja käyttävä protokolla \cite{Caucus}. Merlin-ketjun sijasta kirjoittajat käyttävät nimeä \textit{tiivisteketju}. Caucus yrittää ratkaista konsensusmekanismin johtajan valinnan ongelman tuottamalla satunnaisuutta, jonka mukaan johtaja valitaan. Valittu johtaja vastaa seuraavan satunnaisluvun tuottamisesta paljastamalla tiivisteketjun arvonsa. Protokolla vaatii satunnaisen arvon konfigurointia varten ja kirjoittajat esittävät, että tähän voidaan käyttää esimerkiksi PVSS-protokollaa. Caucus on sovellettavissa PoS-lohkoketjun konsensusmekanismiin, mutta sitä voi käyttää myös lohkoketjusovelluksessa. Kirjoittajat esittävät älysopimustoteutuksen, joka kykeni kirjoitushetkellä 2018 tuottamaan yhden satunnaisluvun 0.1 dollarin kustannuksella. Kommunikointikompleksisuus konfiguroinnin jälkeen on Merlin-ketju-protokollan tapaan O(1), mutta Caucus protokollan arvot ovat manipuloitavissa. Valittu johtaja voi vääristää satunnaisuuden jakaumaa olemalla julkaisematta epäsuotuista tiivisteketjun arvoaan. Caucus jättää tarkoituksella kyseisen ongelman ratkaisun tulevalle tutkimukselle, mutta kirjoittavat esittävät, että manipuloinnin estämiseen voitaisiin käyttää protokollaan osallistumiseen vaadittavaa vakuustalletusta. Vakuustalletus parantaa protokollan Sybil resistenssiä.

Caucus-protokollan manipulointia voisi ehkäistä käyttämällä VDF:ää. Johtaja julkaisisi tiivisteketjun arvonsa lohkoketjuun ja lopullinen satunnainen arvo saataisiin VDF:stä. Varsinaisen tuloksen voisi julkaista kuka tahansa. Tällöin valittu johtaja ei voisi simuloida satunnaista arvoa, eikä täten tehdä päätöstä julkaisemisesta.

Verrattuna Merlin-protokollaan, Caucus-protokollassa on pienempi riski protokollan pysähtymiselle siksi, että Merlin-protokollan tapauksessa satunnaisluvun tuottamiseksi pitää odottaa kaikkia osallistujia, kun taas Caucus-protokollassa tuotettavana oleva satunnaisuus riippuu yhdestä osallistujasta, valitusta johtajasta. Merlin-protokolla on toteutettu älysopimuksena  \cite{MerlinChains}, kuten myös Caucus protokolla \cite{Caucus}, mutta kirjoitushetkellä onnistuin löytämään vain Caucus-protokollan toteutuksen. Saatavilla oleva valmis toteutus helpottaa merkittävästi protokollan käyttöönottoa lohkoketjusovelluksessa.

\section{Homomorfinen salaus (Homomorphic Encryption, HE)}

\textit{Homomorfinen Salaus} mahdollistaa tiettyjen laskutoimitusten suorittamisen salatulla datalla ilman, että salausta puretaan \cite{alma9928100443506253}. Laskutoimitusten tulos vastaa samaa kuin, että laskutoimitukset olisi tehty salaamattomalla datalla. Täysin Homomorfisessa Salauksessa (Fully Homomorphic Encryption, FHE) salatulla datalle voidaan suorittaa mitä tahansa laskentaa. Osittain Homomorfinen Salaus (Partially Homomorphic Encryption, PHE) mahdollistaa vain tiettyjen laskutoimitusten suorittamisen salatulle datalle.

HERB protokolla käyttää satunnaisuuden tuottamiseen Osittain Homomorfista Salausta ja se tuottaa oletuksiensa rajoissa vaatimukset 1-4 täyttäviä satunnaislukuja \cite{cherniaeva2019homomorphic}. HERB olettaa, että osallistujia on $N=3t+1$, joista hyökkääjiä on enintään $t$. HERB konfiguroidaan hajautetulla avainten generoinnilla (Distributed Key Generation, DKG \cite{pedersen1991threshold}), jossa osallistujat generoivat asymmetrisen salauksen avainparin, jonka salainen avain on jaettu N osallistujalle ja salaisen avaimen käyttämiseen salauksen purkamiseksi vaaditaan $t+1$ avaimen osaa. Osallistujat kommitoivat satunnaisuutta salaten sen käyttäen jaettua salaista avainta vastaavaa yhteistä julkista avainta. Vähintään $t+1$ salattua kommitointia lasketaan yhteen, minkä jälkeen $t+1$ osallistujaa purkaa yhteenlaskettujen kommitointien salauksen. Purettu yhteenlaskettu kommitointi toimii satunnaisena arvona. 

DKG protokollasta on olemassaoleva älysopimustoteutus, jossa yksittäisen käyttäjän kommunikaatiokompleksisuus on $O(n)$ \cite{schindler2019ethdkg}. Konfiguroinnin jälkeen yksittäisen HERB osallistujan tarvitsee älysopimustoteutuksessa lähettää satunnaisluvun tuottamiseksi kaksi transaktiota \cite{cherniaeva2019homomorphic}. Itse toteutus ei ole kuitenkaan triviaali sillä se vaatii kryptografista On- ja Off-chain laskentaa. HERB on myös altis Sybil hyökkäyksille, sillä jos protokollaan rekisteröinti on lähes kulutonta, voi hyökkääjä osallistua protokollaan monella tilillä ja täten saada helposti yli $t$ osaa yksityisestä avaimesta. Protokollaan ei voi myöskään liittyä, eikä poistua, vapaasti kesken satunnaislukujen tuottamisen. Uusien osallistujien pitää suorittaa DKG konfigurointi uudestaan. 

HERB protokollasta nostetaan esiin toisista protokollista poikkeava ominaisuus, joka on, että salaisen avaimen osien ryhmä voi olla erillinen satunnaisuutta kommitoivien ryhmästä \cite{cherniaeva2019homomorphic}. Tämä on mahdollista, sillä satunnaisuus salataan käyttäen julkista avainta. Jos kuitenkin käytännön toteutuksessa kommitointi on ilmaista, kaikille avointa ja kommitoidut salaisuudet puretaan kun niitä on saapunut esimerkiksi vähintään $t+1$, niin yksittäinen hyökkääjä voi pahimmassa tapauksessa vastata kaikista kommitoinneista ja täten päättää satunnaisen arvon. Tämä onnistuu niin, että hyökkääjä lähettää heti kommitointi-ikkunan avauduttua eri tileillä $t+1$ kommitointia, niin suurilla transaktiokuluilla, että vain hyökkääjän kommitoinnit menevät läpi. Hyökkäys olisi taloudellisesti kallis, mutta se voisi olla kannattava palkinnon ollessa riittävän suuri.